{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"provider-storage","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The <code>provider-storage</code> Configuration Package is the root project for a collection of different configuration packages that enable the creation of S3-compatible object storage called <code>buckets</code> or <code>containers</code> as well as the possibility to request access from or grant access to those <code>buckets</code>.</p> <p>The following configuration packages are built from <code>provider-storage</code>:</p> <ul> <li><code>storage-minio</code></li> <li><code>storage-aws</code></li> <li><code>storage-scaleway</code></li> </ul>"},{"location":"#first-steps","title":"First steps","text":"<p>Before you can work with any of the configuration packages built from <code>provider-storage</code> you need to install Crossplane into your Kubernetes cluster. An easy way to start testing the configuration package is on a local kind cluster.</p> <p>You can either follow a tutorial to set up everything from scratch to deploy your first Claim or, if you already have experience with Crossplane and Kubernetes, follow a how-to guide on how to install a specific configuration package built from <code>providers-storage</code>.</p>"},{"location":"#getting-help","title":"Getting help","text":"<p>The best way to get help is by creating an issue on GitHub.</p>"},{"location":"#how-the-documentation-is-organized","title":"How the documentation is organized","text":"<p>The documentation is organized in four distinct parts:</p> <ul> <li>Tutorials invite you to follow a series of steps to install, run and deploy your first Claim for each configuration package.</li> <li>How-to guides are more advanced than tutorials and guide you through specific problems and use-cases.</li> <li>Reference guides contain the API definitions for the Composite Resource Definitions of the configuration packages.</li> <li>Discussions provide some insight in the inner workings of the Compositions and some reasoning behind their implementation.</li> </ul> <p>Note</p> <p>All configuration packages built from <code>provider-storage</code> share the same Composite Resource Definition!</p>"},{"location":"discussions/permission-workflow/","title":"Permission Workflow","text":"<p>The permission workflow is one of the core features of <code>provider-storage</code> and makes it possible to request and/or grant permissions from/to other users. For the end user, the functionality of all the Configuration Packages is the same. However, even though MinIO, AWS and Scaleway provide S3-compatible storage backends, they all have their unique limitations. While <code>storage-minio</code> and <code>storage-aws</code> enable the permission workflow through an <code>Object</code> from <code>provider-kubernetes</code>, <code>storage-scaleway</code> uses the capability of <code>function-pyhton</code> to check if permissions have been granted to specific users/applications.</p> <p>We will work through the different Configuration Packages with the following Claim in mind. We don't need to cover Buckets since they are simply created when the Claim is applied.</p> <pre><code>---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n  - bucketName: alice\n  - bucketName: alice-shared\n    discoverable: true\n  bucketAccessRequests:\n  - bucketName: bob-shared\n    permission: ReadWrite\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n  - bucketName: bob\n  - bucketName: bob-shared\n    discoverable: true\n  bucketAccessGrants:\n  - bucketName: bob-shared\n    permission: ReadWrite\n    grantees:\n    - alice\n</code></pre>"},{"location":"discussions/permission-workflow/#storage-minio-and-storage-aws","title":"<code>storage-minio</code> and <code>storage-aws</code>","text":"<p>Both Configuration Packages create multiple IAM Policies which are attached to the user objects. This is already the main difference between these two and <code>storage-scaleway</code> which creates a single Bucket Policy. Let's first imagine that <code>bob</code> has not granted <code>ReadWrite</code> permissions to <code>alice</code> yet but <code>alice</code> has already requested permissions.</p> <p>The Compositions create multiple IAM Policies which follow the pattern <code>&lt;owner&gt;.owner.&lt;bucketName&gt;</code>:</p> <ul> <li>alice.owner.alice</li> <li>alice.owner.alice-shared</li> <li>bob.owner.bob</li> <li>bob.owner.bob-shared</li> </ul> <p>They describe the permissions of each user, i.e. <code>alice</code> owns the Buckets <code>alice</code> and <code>alice-shared</code> and <code>bob</code> owns the Buckets <code>bob</code> and <code>bob-shared</code>. In <code>storage-minio</code> they are added to the <code>User</code> object directly and in <code>storage-aws</code> they are added through a <code>UserPolicyAttachment</code>. However, what we are missing is an IAM police <code>alice.readwrite.bob-shared</code> since <code>bob</code> has not granted any access to his Bucket yet.</p> <p>In order for the Claim to reconcile and continuously check if <code>alice.readwrite.bob-shared</code> exists (i.e. <code>bob</code> has finally granted the request) a Kubernetes Object is created which flips its <code>Ready</code> state to <code>True</code> as soon as the <code>alice.readwrite.bob-shared</code> IAM policy exists. Since the Kubernetes Resource has changed its state, the <code>crossplane</code> controller reconciles the Claim and also attaches <code>alice.readwrite.bob-shared</code> to the <code>User</code>.</p> <p>Lastly, the <code>User</code> object in <code>storage-minio</code> and the <code>AccessKey</code> object in <code>storage-aws</code> generate the corresponding API Keys.</p> <p>One big downside of this approach is that the Claim of <code>alice</code> has the <code>Ready: False</code> state as long as the permission request has not been granted. This is another case where <code>storage-minio</code> and <code>storage-aws</code> differ from <code>storage-scaleway</code>. This will be changed/fixed in a future release of <code>provider-storage</code>.</p>"},{"location":"discussions/permission-workflow/#storage-scaleway","title":"<code>storage-scaleway</code>","text":"<p>As already stated before, the biggest difference between <code>storage-scaleway</code> and the other two Configuration Packages is, that we need to work with Bucket Policies (since this is how Scaleway handles Object Storage permissions) and that we are not using <code>Objects</code> from <code>provider-kubernetes</code>. Scaleway has the limitation that we can only apply one Bucket Policy per Bucket so the <code>owner</code>, <code>ReadWrite</code> and <code>ReadOnly</code> statements are all inside one Bucket Policy and only the <code>Principal</code> (the user/application that these permissions apply to) are added. Furthermore, <code>storage-scaleway</code> does not use <code>User</code> objects but <code>Application</code> objects.</p> <p>Let's assume that only the <code>bob</code> Claim is applied. Since <code>storage-scaleway</code> does not use an <code>Object</code> from <code>provider-kubernetes</code> but the capabilities of <code>function-python</code> the state of the Claim is always <code>Ready: True</code>. Each Claim adds the ID of the <code>User</code> which is used for connecting to Scaleway and the ID of the <code>Application</code> of the owner to the <code>Principal</code> field of the corresponding statement. Furthermore, it checks if the <code>Application</code>, that is granted permission to a bucket, exists and adds it to the <code>Principal</code> of the corresponding permission statement. Since <code>alice</code> does not exist, nothing is added to the Bucket Policy. This way we shift the work of <code>provider-kubernetes</code> into the creation of the Bucket Policy itself and ensure that the Claim always is in a <code>Ready: True</code> state. The following Bucket Policies are created:</p> <ul> <li>bob</li> <li>bob-shared</li> </ul> <p>Let's have a look at <code>bob-shared</code>.</p> <pre><code>{\n  \"Version\": \"2023-04-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"SCW\": [\n          \"user_id:55a79491-d8b1-480b-8b36-f15cea9db176\",\n          \"application_id:a4e57158-651f-441d-8a3c-141b598ec6e7\"\n        ]\n      },\n      \"Action\": [\n        \"s3:*\"\n      ],\n      \"Resource\": [\n        \"bob-bob-shared-a97a5bcb-62d7896f\",\n        \"bob-bob-shared-a97a5bcb-62d7896f/*\"\n      ]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"SCW\": []\n      },\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\"\n      ],\n      \"Resource\": [\n        \"bob-bob-shared-a97a5bcb-62d7896f\",\n        \"bob-bob-shared-a97a5bcb-62d7896f/*\"\n      ]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"SCW\": []\n      },\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\"\n      ],\n      \"Resource\": [\n        \"bob-bob-shared-a97a5bcb-62d7896f\",\n        \"bob-bob-shared-a97a5bcb-62d7896f/*\"\n      ]\n    }\n  ]\n}\n</code></pre> <p>As you can see, <code>bob</code> wanted to grant <code>alice</code> permissions to <code>ReadWrite</code> the <code>bob-shared</code> Bucket but the <code>Application</code> does not exist so nothing is added to the <code>Principal</code> in the second Statement.</p> <p>Now the question is: How does the the <code>crossplane</code> controller now know that it needs to reconcile to check if the <code>Application</code> named <code>alice</code> exists? This is done by <code>function-python</code> since we added <code>alice</code> as a required resource, i.e. as long as <code>alice</code> does not exist the <code>crossplane</code> controller will reconcile. If <code>alice</code> is found, the Bucket Policy is updated and looks something like this:</p> <pre><code>{\n  ...\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"SCW\": [\n          \"application_id:b3d29169-0bb5-4c54-b7d1-b1570a81ef56\"\n        ]\n      },\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\"\n      ],\n      \"Resource\": [\n        \"bob-bob-shared-a97a5bcb-62d7896f\",\n        \"bob-bob-shared-a97a5bcb-62d7896f/*\"\n      ]\n    },\n  ...\n}\n</code></pre> <p>One downside is that there is no way to see who requested access to which Buckets yet. This will be implemented in a future release such that it can be used by external systems that want to build off of it.</p>"},{"location":"discussions/permission-workflow/#conclusion","title":"Conclusion","text":"<p>In conclusion, the difference between <code>storage-minio</code> and <code>storage-aws</code> on the one hand and <code>storage-scaleway</code>on the other hand, comes down to the difference in Policies. While <code>storage-minio</code> and <code>storage-aws</code> create IAM Policies, <code>storage-scaleway</code> creates Bucket Policies. The permission workflow for the first two Configuration Packages works by creating specific <code>Objects</code> with <code>provider-kubernetes</code> that observe if an IAM Policy exists. This implies that the Claim always has the state <code>Ready: False</code> if it does not. The permission workflow for the last Configuration Package works by checking if the specified <code>Application</code>, that permission is granted, exists. The Claim is reconciled as long as the <code>Application</code> does not exist. This implies that the Claim always has the <code>Ready: True</code> state but there is no way (yet) to see if there is a request to a specific Bucket.</p>"},{"location":"how-to-guides/general/","title":"How-to guides: general","text":"<p>All configuration packages in <code>provider-storage</code> allow the creation of S3-compatible <code>Buckets</code> and automatically create <code>Policies</code> for permission control. Furthermore, they include a workflow to request/grant access to <code>Buckets</code> from other <code>owners</code>.</p>"},{"location":"how-to-guides/general/#how-to-guides","title":"How-to guides","text":"<ul> <li>How to create <code>Buckets</code></li> <li>How to request access to <code>Buckets</code> from other <code>owners</code></li> <li>How to grant access to <code>Buckets</code> to other <code>owners</code></li> </ul>"},{"location":"how-to-guides/general/#how-to-create-buckets","title":"How to create <code>Buckets</code>","text":"<p>In order to create buckets you need to specify the <code>owner</code> and the <code>bucketName</code>. Additionally, you can set the flag <code>discoverable</code> to true which adds an annotation <code>xstorages.pkg.internal/discoverable</code> to the bucket resource.</p> <pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nspec:\n  owner: &lt;owner&gt;\n  buckets:\n    - bucketName: &lt;bucketName&gt;\n    - bucketName: &lt;bucketName&gt;\n      discoverable: true\n</code></pre>"},{"location":"how-to-guides/general/#how-to-request-access-to-buckets-from-other-owners","title":"How to request access to <code>Buckets</code> from other <code>owners</code>","text":"<p>If an <code>owner</code> wants to request access to a bucket from another <code>owner</code> it can just be added to a claim by specifying the <code>bucketAccessRequests</code>. The permission can either be <code>ReadWrite</code> or <code>ReadOnly</code>.</p> <pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nspec:\n  ...\n  owner: &lt;owner&gt;\n  bucketAccessRequests:\n    - bucketName: &lt;bucketName&gt;\n      permissions: &lt;permission&gt;\n  ...\n</code></pre> <p>This creates a Kubernetes object with <code>provider-kubernetes</code> that observes if the <code>&lt;owner&gt;.&lt;permission&gt;.&lt;bucketName&gt;</code> exists. If the other <code>owner</code> has not granted access to the requested bucket yet (this means that the policy does not exist yet), the <code>XStorage</code> object will switch to <code>READY: False</code> and trigger the <code>crossplane</code> reconciliation loop which continuously checks if the policy exists.</p> <p>If access is granted to the bucket, the policy is created and attached to the <code>User</code> object of the <code>owner</code>. This switches the status of the <code>XStorage</code> object back to <code>READY: True</code>.</p>"},{"location":"how-to-guides/general/#how-to-grant-access-to-buckets-to-other-owners","title":"How to grant access to <code>Buckets</code> to other <code>owners</code>","text":"<p>It is possible to grant <code>owners</code> access to a bucket without them first requesting access. However, it is only attached to the user role if the user has requested access to it as well. Similarly to the requests, the claim can include <code>bucketAccessGrants</code> that grant permissions (<code>ReadWrite</code> or <code>ReadOnly</code>) to a bucket to a list of <code>grantees</code>.</p> <pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nspec:\n  ...\n  owner: &lt;owner&gt;\n  bucketAccessGrants:\n    - bucketName: &lt;bucketName&gt;\n      permissions: &lt;permission&gt;\n      grantees:\n        - &lt;grantee&gt;\n  ...\n</code></pre> <p>This creates the <code>&lt;grantee&gt;.&lt;permission&gt;.&lt;bucketName&gt;</code> policy so if the <code>grantee</code> request access to this bucket, they are automatically granted access.</p>"},{"location":"how-to-guides/storage-aws/","title":"How-to guides: storage-aws","text":"<p>The <code>storage-aws</code> configuration package allows the creation of S3-compatible <code>Buckets</code> on AWS and automatically creates <code>Policies</code> for permission control. Furthermore, <code>storage-aws</code> includes a workflow to request/grant access to <code>Buckets</code> from other <code>owners</code>.</p>"},{"location":"how-to-guides/storage-aws/#how-to-guides","title":"How-to guides","text":"<ul> <li>How to install the <code>storage-aws</code> configuration package</li> </ul>"},{"location":"how-to-guides/storage-aws/#how-to-install-the-storage-aws-configuration-package","title":"How to install the <code>storage-aws</code> configuration package","text":"<p>The <code>storage-aws</code> configuration package can be installed like any other configuration package with</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-aws\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/aws:0.1-beta.3\n</code></pre> <p>This automatically installs the necessary dependencies:</p> <ul> <li>provider-aws-s3 &gt;= v2.0.0</li> <li>provider-aws-iam &gt;= v2.0.0</li> <li>provider-kubernetes &gt;= v0.18.0</li> <li>function-auto-ready &gt;= 0.5.0</li> <li>function-go-templating &gt;= v0.10.0</li> <li>function-python &gt;= v0.2.0</li> </ul> <p>However, it does not install the necessary <code>ProviderConfigs</code>, <code>ServiceAccounts</code> and <code>Secrets</code> that are actually needed for the <code>storage-aws</code> to work.</p> <p>The <code>provider-aws</code> needs credentials for AWS. Therefore, it needs a <code>Secret</code> which includes the access key and secret key.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: storage-aws\n  namespace: crossplane-system\nstringData:\n  credentials: |\n    [default]\n    aws_access_key_id = &lt;aws-access-key-id&gt;\n    aws_secret_access_key = &lt;aws-secret-access-key&gt;\n</code></pre> <p>Furthermore, the <code>ProviderConfig</code> needs to reference this secret.</p> <p>Warning</p> <p>The name of the <code>ProviderConfig</code> needs to be <code>storage-aws</code>! The composition will not work with any other name and will not be able to create resources!</p> <pre><code>apiVersion: aws.upbound.io/v1beta1\nkind: ProviderConfig\nmetadata:\n  name: storage-aws\nspec:\n  credentials:\n    source: Secret\n    secretRef:\n      name: storage-aws\n      namespace: crossplane-system\n      key: credentials\n</code></pre> <p>The <code>provider-kubernetes</code> needs a <code>ServiceAccount</code> that can observe resources from <code>policies.iam.aws.upbound.io</code>. Below is an example <code>ClusterRole</code> which expands the default <code>ClusterRole</code> created by <code>crossplane-rbac</code>.</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: storage-kubernetes\nrules:\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - objects\n      - objects/status\n      - observedobjectcollections\n      - observedobjectcollections/status\n      - providerconfigs\n      - providerconfigs/status\n      - providerconfigusages\n      - providerconfigusages/status\n    verbs:\n      - get\n      - list\n      - watch\n      - update\n      - patch\n      - create\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - \"*/finalizers\"\n    verbs:\n      - update\n  - apiGroups:\n      - coordination.k8s.io\n    resources:\n      - secrets\n      - configmaps\n      - events\n      - leases\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - iam.aws.upbound.io\n    resources:\n      - policies\n    verbs:\n      - watch\n      - get\n</code></pre> <p>When the <code>ClusterRole</code> is attached to the <code>ServiceAccount</code> via a <code>ClusterRoleBinding</code>, the actual <code>provider-kubernetes</code> can be updated with a <code>DeploymentRuntimeConfig</code> to use the newly created <code>ServiceAccount</code>. Furthermore, a standard <code>ProviderConfig</code> can be applied.</p> <p>Warning</p> <p>Make sure that the <code>name</code> and version of the <code>Provider</code> matches the name of the Kubernetes provider that is already installed in your cluster! If it does not match, <code>crossplane</code> installs a new Kubernetes provider with the given name. The standard name is <code>crossplane-contrib-provider-kubernetes</code> if the provider was installed as part of the dependencies in the configuration package.</p> <p>Warning</p> <p>The name of the <code>ProviderConfig</code> needs to be <code>storage-kubernetes</code>! The composition will not work with any other name and will not be able to observe resources!</p> <pre><code>---\napiVersion: pkg.crossplane.io/v1\nkind: Provider\nmetadata:\n  name: &lt;name&gt;\nspec:\n  package: xpkg.upbound.io/crossplane-contrib/provider-kubernetes:&lt;version&gt;\n  runtimeConfigRef:\n    apiVersion: pkg.crossplane.io/v1beta1\n    kind: DeploymentRuntimeConfig\n    name: &lt;deploymenRuntimeConfigName&gt;\n---\napiVersion: pkg.crossplane.io/v1beta1\nkind: DeploymentRuntimeConfig\nmetadata:\n  name: &lt;name&gt;\nspec:\n  serviceAccountTemplate:\n    metadata:\n      name: &lt;serviceAccountName&gt;\n---\napiVersion: kubernetes.crossplane.io/v1alpha1\nkind: ProviderConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  credentials:\n    source: InjectedIdentity\n</code></pre> <p>This is everything that is needed for the <code>storage-aws</code> configuration package to function properly.</p>"},{"location":"how-to-guides/storage-minio/","title":"How-to guides: storage-minio","text":"<p>The <code>storage-minio</code> configuration package allows the creation of <code>buckets</code> on a MinIO backend and automatically creates Policies for permission control. Furthermore, <code>storage-minio</code> includes a workflow to request/grant access to <code>buckets</code> from other <code>owners</code>.</p>"},{"location":"how-to-guides/storage-minio/#how-to-guides","title":"How-to guides","text":"<ul> <li>How to install the <code>storage-minio</code> configuration package</li> </ul>"},{"location":"how-to-guides/storage-minio/#how-to-install-the-storage-minio-configuration-package","title":"How to install the <code>storage-minio</code> configuration package","text":"<p>The <code>storage-minio</code> configuration package can be installed like any other configuration package with</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-minio\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/minio:0.1-beta.3\n</code></pre> <p>This automatically installs the necessary dependencies:</p> <ul> <li>provider-minio &gt;= v0.4.4</li> <li>provider-kubernetes &gt;= v0.18.0</li> <li>function-auto-ready &gt;= 0.5.0</li> <li>function-go-templating &gt;= v0.10.0</li> </ul> <p>However, it does not install the necessary <code>ProviderConfigs</code>, <code>ServiceAccounts</code> and <code>Secrets</code> that are actually needed for the <code>storage-minio</code> to work.</p> <p>The <code>provider-minio</code> needs to know how to access the MinIO instance and also needs credentials for it. Therefore, it needs a <code>Secret</code> which includes the access key and secret key.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nstringData:\n  AWS_ACCESS_KEY_ID: &lt;Access Key&gt;\n  AWS_SECRET_ACCESS_KEY: &lt;Secret Key&gt;\n</code></pre> <p>Furthermore, the <code>ProviderConfig</code> needs to reference this secret and also provide the URL for the MinIO instance.</p> <p>Warning</p> <p>The name of the <code>ProviderConfig</code> needs to be <code>storage-minio</code>! The composition will not work with any other name and will not be able to create resources!</p> <pre><code>apiVersion: minio.crossplane.io/v1\nkind: ProviderConfig\nmetadata:\n  name: storage-minio\n  namespace: crossplane-system\nspec:\n  credentials:\n    apiSecretRef:\n      name: &lt;secretName&gt;\n      namespace: &lt;secretNamespace&gt;\n    source: InjectedIdentity\n  minioURL: &lt;url&gt;\n</code></pre> <p>The <code>provider-kubernetes</code> needs a <code>ServiceAccount</code> that can observe resources from <code>policies.minio.crossplane.io</code>. Below is an example <code>ClusterRole</code> which expands the default <code>ClusterRole</code> created by <code>crossplane-rbac</code>.</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: &lt;name&gt;\nrules:\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - objects\n      - objects/status\n      - observedobjectcollections\n      - observedobjectcollections/status\n      - providerconfigs\n      - providerconfigs/status\n      - providerconfigusages\n      - providerconfigusages/status\n    verbs:\n      - get\n      - list\n      - watch\n      - update\n      - patch\n      - create\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - \"*/finalizers\"\n    verbs:\n      - update\n  - apiGroups:\n      - coordination.k8s.io\n    resources:\n      - secrets\n      - configmaps\n      - events\n      - leases\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - minio.crossplane.io\n    resources:\n      - policies\n    verbs:\n      - watch\n      - get\n</code></pre> <p>When the <code>ClusterRole</code> is attached to the <code>ServiceAccount</code> via a <code>ClusterRoleBinding</code>, the actual <code>provider-kubernetes</code> can be updated with a <code>DeploymentRuntimeConfig</code> to use the newly created <code>ServiceAccount</code>. Furthermore, a standard <code>ProviderConfig</code> can be applied.</p> <p>Warning</p> <p>Make sure that the <code>name</code> and version of the <code>Provider</code> matches the name of the Kubernetes provider that is already installed in your cluster! If it does not match, <code>crossplane</code> installs a new Kubernetes provider with the given name. The standard name is <code>crossplane-contrib-provider-kubernetes</code> if the provider was installed as part of the dependencies in the configuration package.</p> <p>Warning</p> <p>The name of the <code>ProviderConfig</code> needs to be <code>storage-kubernetes</code>! The composition will not work with any other name and will not be able to observe resources!</p> <pre><code>---\napiVersion: pkg.crossplane.io/v1\nkind: Provider\nmetadata:\n  name: &lt;name&gt;\nspec:\n  package: xpkg.crossplane.io/crossplane-contrib/provider-kubernetes:&lt;version&gt;\n  runtimeConfigRef:\n    apiVersion: pkg.crossplane.io/v1beta1\n    kind: DeploymentRuntimeConfig\n    name: &lt;deploymenRuntimeConfigName&gt;\n---\napiVersion: pkg.crossplane.io/v1beta1\nkind: DeploymentRuntimeConfig\nmetadata:\n  name: &lt;name&gt;\nspec:\n  serviceAccountTemplate:\n    metadata:\n      name: &lt;serviceAccountName&gt;\n---\napiVersion: kubernetes.crossplane.io/v1alpha1\nkind: ProviderConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  credentials:\n    source: InjectedIdentity\n</code></pre> <p>This is everything that is needed for the <code>storage-minio</code> configuration package to function properly.</p>"},{"location":"how-to-guides/storage-scaleway/","title":"How-to guides: storage-scaleway","text":"<p>The <code>storage-scaleway</code> configuration package allows the creation of S3-compatible <code>Buckets</code> on Scaleway and automatically creates <code>Policies</code> for permission control. Furthermore, <code>storage-scaleway</code> includes a workflow to request/grant access to <code>Buckets</code> from other <code>owners</code>.</p>"},{"location":"how-to-guides/storage-scaleway/#how-to-guides","title":"How-to guides","text":"<ul> <li>How to install the <code>storage-scaleway</code> configuration package</li> </ul>"},{"location":"how-to-guides/storage-scaleway/#how-to-install-the-storage-scaleway-configuration-package","title":"How to install the <code>storage-scaleway</code> configuration package","text":"<p>Warning</p> <p>In order for <code>storage-scaleway</code> to work you need enable Operations when installing Crossplane!</p> <p>The <code>storage-scaleway</code> configuration package can be installed like any other configuration package with</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-scaleway\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/scaleway:0.1-beta.3\n</code></pre> <p>This automatically installs the necessary dependencies:</p> <ul> <li>provider-scaleway &gt;= v0.4.0</li> <li>function-auto-ready &gt;= 0.5.0</li> <li>function-python &gt;= v0.2.0</li> </ul> <p>However, it does not install the necessary <code>ProviderConfig</code> and <code>Secret</code> that are actually needed for the <code>storage-scaleway</code> to work.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: storage-scaleway\n  namespace: crossplane-system\ntype: Opaque\nstringData:\n  credentials: |\n    {\n      \"access_key\": \"&lt;scaleway-access-key-id&gt;\",\n      \"secret_key\": \"&lt;scaleway-secret-access-key&gt;\",\n      \"organization_id\": \"&lt;scaleway-organization-id&gt;\",\n      \"user_id\": \"&lt;scaleway-user-id&gt;\",\n      \"region\": \"fr-par\",\n      \"zone\": \"fr-par-1\"\n    }\n</code></pre> <p>Warning</p> <p>In the README for <code>provider-scaleway</code>, the <code>user_id</code> is not present but it is essential for <code>storage-scaleway</code> to work! This is the user ID of the user/application associated with the <code>access_key</code>.</p> <p>Furthermore, the <code>ProviderConfig</code> needs to reference this secret.</p> <p>Warning</p> <p>The name of the <code>ProviderConfig</code> needs to be <code>storage-scaleway</code>! The composition will not work with any other name and will not be able to create resources!</p> <pre><code>apiVersion: scaleway.upbound.io/v1beta1\nkind: ProviderConfig\nmetadata:\n  name: storage-scaleway\nspec:\n  credentials:\n    source: Secret\n    secretRef:\n      name: storage-scaleway\n      namespace: crossplane-system\n      key: credentials\n</code></pre> <p>This is everything that is needed for the <code>storage-scaleway</code> configuration package to function properly.</p>"},{"location":"reference-guides/api/","title":"API Reference","text":"<p>Packages:</p> <ul> <li>pkg.internal/v1beta1</li> </ul>"},{"location":"reference-guides/api/#pkginternalv1beta1","title":"pkg.internal/v1beta1","text":"<p>Resource Types:</p> <ul> <li>Storage</li> </ul>"},{"location":"reference-guides/api/#storage","title":"Storage","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required apiVersion string pkg.internal/v1beta1 true kind string Storage true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object            Spec defines the desired state of Storage. false status object            Status defines the observed status of Storage. false"},{"location":"reference-guides/api/#storagespec","title":"Storage.spec","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Spec defines the desired state of Storage.</p> Name Type Description Required buckets []object            List of buckets to create and which are owned by the owner. true owner string            Owner of the buckets to create. true bucketAccessGrants []object            List of buckets where the owner grants either ReadWrite or ReadOnly permissions to other owners (defined in separate Storage claims). false bucketAccessRequests []object            List of buckets where the owner requests either ReadWrite or ReadOnly permissions from other owners (defined in separate Storage claims). false"},{"location":"reference-guides/api/#storagespecbucketsindex","title":"Storage.spec.buckets[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket to create. true discoverable boolean            Whether this bucket should be discoverable through the catalog by other owners (defined in separate Storage claims). Default: false false"},{"location":"reference-guides/api/#storagespecbucketaccessgrantsindex","title":"Storage.spec.bucketAccessGrants[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket to grant permissions to. true grantees []string            List of owners (defined in separate Storage claims) that the permission is granted to. true permission enum            Permission that is granted. Enum: ReadWrite, ReadOnly true"},{"location":"reference-guides/api/#storagespecbucketaccessrequestsindex","title":"Storage.spec.bucketAccessRequests[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket to request permissions to. true permission enum            Permission that is requested. Enum: ReadWrite, ReadOnly true"},{"location":"reference-guides/api/#storagestatus","title":"Storage.status","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Status defines the observed status of Storage.</p> Name Type Description Required storage object            Information about connection details and buckets associated to the owner. false"},{"location":"reference-guides/api/#storagestatusstorage","title":"Storage.status.storage","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Information about connection details and buckets associated to the owner.</p> Name Type Description Required buckets []object            List of buckets to associated with the owner. false"},{"location":"reference-guides/api/#storagestatusstoragebucketsindex","title":"Storage.status.storage.buckets[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket. false permission enum            Permission asssociated with the bucket. Enum: ReadWrite, ReadOnly false status enum            Status of the permission access to the bucket. Enum: Owned, Requested, Granted, Denied false"},{"location":"tutorials/storage-aws/","title":"Tutorials: storage-aws","text":"<p>These tutorials offer a series of steps to install, run and deploy your first <code>Claim</code> for the <code>storage-aws</code> configuration package. We are going to create buckets for Alice and Bob, two imaginary users. Then, Alice is going to request access to a bucket which is owned by Bob and in the last step Bob is going to grant access to Alice for this bucket.</p>"},{"location":"tutorials/storage-aws/#prerequisites","title":"Prerequisites","text":"<p>This tutorial assumes that you have go, kubectl and helm installed on your machine. Furthermore, we are using a local kind cluster for this tutorial. You can find installation instructions here.</p>"},{"location":"tutorials/storage-aws/#kind-cluster-and-crossplane-installation","title":"<code>kind</code> cluster and <code>crossplane</code> installation","text":"<p>After you have installed the necessary tools, we can create a new cluster with</p> <pre><code>kind create cluster --name storage-aws\n</code></pre> <p>and check if everything is working with</p> <pre><code>kubectl get pods -A\n</code></pre> <p>If the cluster is up and running, we need to install Crossplane. You can find more information about the installation process here.</p> <pre><code>helm repo add crossplane-stable https://charts.crossplane.io/stable\nhelm repo update\nhelm install crossplane \\\n--namespace crossplane-system \\\n--create-namespace crossplane-stable/crossplane \\\n--version 2.0.2 \\\n--set provider.defaultActivations={} \\\n--set args={\"--enable-operations\"}\n</code></pre> <p>In order to reduce the strain on the control plane nodes, we also apply a ManagedResourceActivationPolicy and only activate the resources we need.</p> <pre><code># mrap.yaml\n\napiVersion: apiextensions.crossplane.io/v1alpha1\nkind: ManagedResourceActivationPolicy\nmetadata:\n  name: storage-aws\nspec:\n  activate:\n  - buckets.s3.aws.upbound.io\n  - accesskeys.iam.aws.upbound.io\n  - policies.iam.aws.upbound.io\n  - users.iam.aws.upbound.io\n  - userpolicyattachments.iam.aws.upbound.io\n  - objects.kubernetes.crossplane.io\n\n</code></pre> <pre><code>kubectl apply -f mrap.yaml\n</code></pre>"},{"location":"tutorials/storage-aws/#storage-aws-configuration-package-installation","title":"<code>storage-aws</code> configuration package installation","text":"<p>In order to install the <code>storage-aws</code> configuration package, we first need to create a <code>Configuration</code>.</p> <pre><code># configuration.yaml\n\napiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-aws\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/aws:0.1-beta.3\n</code></pre> <p>Then, we need to apply it to the cluster with</p> <pre><code>kubectl apply -f configuration.yaml\n</code></pre> <p>This automatically installs the necessary dependencies specified in the configuration package:</p> <ul> <li>provider-aws-s3 &gt;= v2.0.0</li> <li>provider-aws-iam &gt;= v2.0.0</li> <li>provider-kubernetes &gt;= v0.18.0</li> <li>function-auto-ready &gt;= 0.5.0</li> <li>function-go-templating &gt;= v0.10.0</li> <li>function-python &gt;= v0.2.0</li> </ul> <p>You can check this by running</p> <pre><code>kubectl get pods -A\n</code></pre> <p>and confirm that you see pods name <code>crossplane-contrib-function-auto-ready-...</code>, <code>crossplane-contrib-provider-kubernetes-...</code>, etc. Furthermore, you should now see one <code>CompositeResourceDefinition</code> or <code>XRD</code> and one <code>Composition</code> with</p> <pre><code>kubectl get xrds\nkubectl get compositions\n</code></pre> <p>The <code>storage-aws</code> configuration package is now installed. However, it is not functional yet since it does not install the necessary <code>ProviderConfigs</code>, <code>ServiceAccounts</code>, <code>ClusterRoles</code>, <code>ClusterRoleBindings</code> and <code>Secrets</code> that are needed by the <code>provider-aws-s3</code>, <code>provider-aws-iam</code> and <code>provider-kubernetes</code>.</p>"},{"location":"tutorials/storage-aws/#provider-aws-s3-and-provider-aws-iam-configuration","title":"<code>provider-aws-s3</code> and <code>provider-aws-iam</code> configuration","text":"<p>For <code>storage-aws</code> to work, we need to configure the providers with a <code>ProviderConfig</code>.</p> <p>Let's start with <code>provider-aws-s3</code> and <code>provider-aws-iam</code>. In order for the provider to know where to actually create the resources specified in the Crossplane composition, we need to provide it with connection details through a <code>ProviderConfig</code>.</p> <p>We need to create a <code>Secret</code> with the access keys for <code>provider-aws-s3</code> and <code>provider-aws-iam</code> to connect.</p> <pre><code># secret.yaml\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: storage-aws\n  namespace: crossplane-system\nstringData:\n  credentials: |\n    [default]\n    aws_access_key_id = &lt;aws-access-key-id&gt;\n    aws_secret_access_key = &lt;aws-secret-access-key&gt;\n</code></pre> <pre><code>kubectl apply -f secret.yaml\n</code></pre> <p>Finally, we can finish the setup for <code>provider-aws-s3</code> and <code>provider-aws-iam</code> by applying a <code>ProviderConfig</code> that references this secret.</p> <pre><code># aws-provider-config.yaml\n\napiVersion: aws.upbound.io/v1beta1\nkind: ProviderConfig\nmetadata:\n  name: storage-aws\nspec:\n  credentials:\n    source: Secret\n    secretRef:\n      name: storage-aws\n      namespace: crossplane-system\n      key: credentials\n</code></pre> <pre><code>kubectl apply -f aws-provider-config.yaml\n</code></pre> <p>That's it for <code>provider-aws-s3</code> and <code>provider-aws-iam</code>.</p>"},{"location":"tutorials/storage-aws/#provider-kubernetes-configuration","title":"<code>provider-kubernetes</code> configuration","text":"<p>The second provider needed for <code>storage-aws</code> is <code>provider-kubernetes</code>. Since we want to observe <code>Policies</code> created by <code>provider-aws-iam</code>, we need to create a <code>ServiceAccount</code> for <code>provider-kubernetes</code> that actually has permissions to observe these resources.</p> <p>The following file creates a <code>ServiceAccount</code>, <code>ClusterRole</code> and <code>ClusterRoleBinding</code> for those permissions.</p> <pre><code># rbac.yaml\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: storage-kubernetes\nrules:\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - objects\n      - objects/status\n      - observedobjectcollections\n      - observedobjectcollections/status\n      - providerconfigs\n      - providerconfigs/status\n      - providerconfigusages\n      - providerconfigusages/status\n    verbs:\n      - get\n      - list\n      - watch\n      - update\n      - patch\n      - create\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - \"*/finalizers\"\n    verbs:\n      - update\n  - apiGroups:\n      - coordination.k8s.io\n    resources:\n      - secrets\n      - configmaps\n      - events\n      - leases\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - iam.aws.upbound.io\n    resources:\n      - policies\n    verbs:\n      - watch\n      - get\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: storage-kubernetes\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: storage-kubernetes\nsubjects:\n  - kind: ServiceAccount\n    name: storage-kubernetes\n    namespace: crossplane-system\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: storage-kubernetes\n  namespace: crossplane-system\n</code></pre> <pre><code>kubectl apply -f rbac.yaml\n</code></pre> <p>Now we can update <code>provider-kubernetes</code> with a <code>DeploymentRuntimeConfig</code> to use this new <code>ServiceAccount</code>. Additionally, we provide the basic <code>ProviderConfig</code> needed by <code>provider-kubernetes</code>.</p> <pre><code># kubernetes-provider-config.yaml\n---\napiVersion: pkg.crossplane.io/v1\nkind: Provider\nmetadata:\n  name: crossplane-contrib-provider-kubernetes\nspec:\n  package: xpkg.upbound.io/crossplane-contrib/provider-kubernetes:v0.18.0\n  runtimeConfigRef:\n    apiVersion: pkg.crossplane.io/v1beta1\n    kind: DeploymentRuntimeConfig\n    name: storage-kubernetes\n---\napiVersion: pkg.crossplane.io/v1beta1\nkind: DeploymentRuntimeConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  serviceAccountTemplate:\n    metadata:\n      name: storage-kubernetes\n---\napiVersion: kubernetes.crossplane.io/v1alpha1\nkind: ProviderConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  credentials:\n    source: InjectedIdentity\n</code></pre> <pre><code>kubectl apply -f kubernetes-provider-config.yaml\n</code></pre> <p>That's it for <code>provider-kubernetes</code> and the complete installation of <code>storage-aws</code>! Now we can finally create our first claim and see the configuration package in action!</p>"},{"location":"tutorials/storage-aws/#creating-buckets-for-alice-and-bob","title":"Creating <code>Buckets</code> for Alice and Bob","text":"<p>Everything is up and running and we can create our first claim - or rather, our first claims! Let's assume that, by default, we need two buckets for every user of the platform. Therefore, we create two two buckets named <code>alice</code> and <code>alice-shared</code> for the user \"Alice\" and <code>bob</code> and <code>bob-shared</code> for the user \"Bob\".</p> <pre><code># claims.yaml\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre>"},{"location":"tutorials/storage-aws/#requesting-access-to-buckets-from-bob","title":"Requesting access to <code>Buckets</code> from Bob","text":"<p>Now that everyone has their buckets, Alice wants to have access to <code>bob-shared</code> since both are working on a project together and she needs access to his results. Since Alice also needs to upload her results to that bucket she needs <code>ReadWrite</code> access.</p> <pre><code># claims.yaml\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre> <p>Note that the status of the <code>XStorage</code> object <code>alice-...</code> has changed to <code>READY: False</code> since the <code>alice.readwrite.bob-shared</code> policy does not exist yet and, therefore, cannot be attached to the user role.</p> <pre><code>kubectl get xstorages\n\n# Output\nNAME          SYNCED   READY   COMPOSITION        AGE\nalice-d7kbk   True     False   provider-storage   13m\nbob-2s79f     True     True    provider-storage   13m\n</code></pre> <pre><code>kubectl get objects.kubernetes.crossplane.io\n\n# Output\nNAME                                         KIND     PROVIDERCONFIG       SYNCED   READY   AGE\npolicy-observer-alice.readwrite.bob-shared   Policy   storage-kubernetes   False            87s\n</code></pre>"},{"location":"tutorials/storage-aws/#granting-access-to-buckets-to-alice","title":"Granting access to <code>Buckets</code> to Alice","text":"<p>Bob is the <code>owner</code> of <code>bob-shared</code> so he needs to grant Alice the <code>ReadWrite</code> permission to the bucket.</p> <pre><code># claims.yaml\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n  bucketAccessGrants:\n    - bucketName: bob-shared\n      permission: ReadWrite\n      grantees:\n        - alice\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre> <p>Note that it can take up to two minutes until the new policy is observed and synced. The status of the <code>XStorage</code> object has changed back to <code>READY: True</code> since the <code>alice.readwrite.bob-shared</code> policy has been created (Bob granted access to Alice) and is now attached to the user role.</p> <pre><code>kubectl get xstorages\n\n# Output\nNAME          SYNCED   READY   COMPOSITION        AGE\nalice-d7kbk   True     True    storage-minio      15m\nbob-2s79f     True     True    storage-minio      15m\n</code></pre> <pre><code>kubectl get objects.kubernetes.crossplane.io\n\n# Output\nNAME                                         KIND     PROVIDERCONFIG       SYNCED   READY   AGE\npolicy-observer-alice.readwrite.bob-shared   Policy   storage-kubernetes   False            87s\n</code></pre> <pre><code>kubectl get userpolicyattachments.iam.aws.upbound.io\n\n# Output\nNAME                         SYNCED   READY   EXTERNAL-NAME                      AGE\nalice.owner.alice            True     True    alice-20250815121642974900000002   13m\nalice.owner.alice-shared     True     True    alice-20250815121642980400000004   13m\nalice.readwrite.bob-shared   True     True    alice-20250815122824423600000005   2m4s\nbob.owner.bob                True     True    bob-20250815121642978200000003     13m\nbob.owner.bob-shared         True     True    bob-20250815121642972100000001     13m\n</code></pre>"},{"location":"tutorials/storage-aws/#conclusion","title":"Conclusion","text":"<p>Congratulations! You have worked through the whole tutorial and have installed <code>storage-aws</code> and deployed your first claims. You should no be able to follow most of the How-to guides in the sidebar and look through the API definitions in the Reference guides and see what other options you can enable/disable in the claims.</p> <p>We are always happy about feedback and suggestions on how to improve the documentation or <code>provider-storage</code> as a whole. Therefore, if you have trouble following the tutorial or find errors please open an issue on GitHub and let us know about it!</p>"},{"location":"tutorials/storage-minio/","title":"Tutorials: storage-minio","text":"<p>These tutorials offer a series of steps to install, run and deploy your first <code>Claim</code> for the <code>storage-minio</code> configuration package. We are going to create buckets for Alice and Bob, two imaginary users. Then, Alice is going to request access to a bucket which is owned by Bob and in the last step Bob is going to grant access to Alice for this bucket.</p>"},{"location":"tutorials/storage-minio/#prerequisites","title":"Prerequisites","text":"<p>This tutorial assumes that you have go, kubectl and helm installed on your machine. Furthermore, we are using a local kind cluster for this tutorial. You can find installation instructions here.</p>"},{"location":"tutorials/storage-minio/#kind-cluster-and-crossplane-installation","title":"<code>kind</code> cluster and <code>crossplane</code> installation","text":"<p>After you have installed the necessary tools, we can create a new cluster with</p> <pre><code>kind create cluster --name storage-minio\n</code></pre> <p>and check if everything is working with</p> <pre><code>kubectl get pods -A\n</code></pre> <p>If the cluster is up and running, we need to install Crossplane. You can find more information about the installation process here.</p> <pre><code>helm repo add crossplane-stable https://charts.crossplane.io/stable\nhelm repo update\nhelm install crossplane \\\n--namespace crossplane-system \\\n--create-namespace crossplane-stable/crossplane \\\n--version 2.0.2 \\\n--set provider.defaultActivations={}\n</code></pre> <p>In order to reduce the strain on the control plane nodes, we also apply a ManagedResourceActivationPolicy and only activate the resources we need.</p> <pre><code># mrap.yaml\n\napiVersion: apiextensions.crossplane.io/v1alpha1\nkind: ManagedResourceActivationPolicy\nmetadata:\n  name: storage-minio\nspec:\n  activate:\n  - buckets.minio.crossplane.io\n  - policies.minio.crossplane.io\n  - users.minio.crossplane.io\n  - objects.kubernetes.crossplane.io\n</code></pre> <pre><code>kubectl apply -f mrap.yaml\n</code></pre>"},{"location":"tutorials/storage-minio/#minio-installation","title":"MinIO installation","text":"<p>In order to test the functionality of <code>storage-minio</code> we need a MinIO installation. For this tutorial we install MinIO into our cluster as well.</p> <p>First, we need to install the <code>minio-operator</code>.</p> <pre><code>helm repo add minio-operator https://operator.min.io\nhelm install \\\n  --namespace minio-operator \\\n  --create-namespace \\\n  operator minio-operator/operator\n</code></pre> <p>Next, we need to install a <code>minio-tenant</code>. This is where our <code>Buckets</code>, <code>Policies</code> and <code>Users</code> actually live. Since this is only for testing, we will make the footprint of the tenant as small as possible by configuring the installation with a <code>values.yaml</code> file.</p> <pre><code># values.yaml\n\ntenant:\n  pools:\n    - servers: 1\n      name: pool-0\n      volumesPerServer: 1\n      size: 1Gi\n  certificate:\n    requestAutoCert: false\n</code></pre> <p>Now we can install the <code>minio-tenant</code> with</p> <pre><code>helm install \\\n  --values values.yaml \\\n  --namespace minio-tenant \\\n  --create-namespace \\\n  minio-tenant minio-operator/tenant\n</code></pre> <p>This concludes the prerequisites and we can finally isntall the <code>storage-minio</code> configuration package.</p>"},{"location":"tutorials/storage-minio/#storage-minio-configuration-package-installation","title":"<code>storage-minio</code> configuration package installation","text":"<p>In order to install the <code>storage-minio</code> configuration package, we first need to create a <code>Configuration</code>.</p> <pre><code># configuration.yaml\n\napiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-minio\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/minio:0.1-beta.3\n</code></pre> <p>Then, we need to apply it to the cluster with</p> <pre><code>kubectl apply -f configuration.yaml\n</code></pre> <p>This automatically installs the necessary dependencies specified in the configuration package:</p> <ul> <li>provider-minio &gt;= v0.4.4</li> <li>provider-kubernetes &gt;= v0.18.0</li> <li>function-auto-ready &gt;= 0.5.0</li> <li>function-go-templating &gt;= v0.10.0</li> </ul> <p>You can check this by running</p> <pre><code>kubectl get pods -A\n</code></pre> <p>and confirm that you see pods name <code>crossplane-contrib-function-auto-ready-...</code>, <code>crossplane-contrib-provider-kubernetes-...</code>, etc. Furthermore, you should now see one <code>CompositeResourceDefinition</code> or <code>XRD</code> and one <code>Composition</code> with</p> <pre><code>kubectl get xrds\nkubectl get compositions\n</code></pre> <p>The <code>storage-minio</code> configuration package is now installed. However, it is not functional yet since it does not install the necessary <code>ProviderConfigs</code>, <code>ServiceAccounts</code>, <code>ClusterRoles</code>, <code>ClusterRoleBindings</code> and <code>Secrets</code> that are needed by the <code>provider-minio</code> and <code>provider-kubernetes</code>.</p>"},{"location":"tutorials/storage-minio/#provider-minio-configuration","title":"<code>provider-minio</code> configuration","text":"<p>For <code>storage-minio</code> to work, we need to configure the providers with a <code>ProviderConfig</code>.</p> <p>Let's start with <code>provider-minio</code>. In order for the provider to know where to actually create the resources specified in the Crossplane composition, we need to provide it with connection details through a <code>ProviderConfig</code>.</p> <p>Since we are using the MinIO instance installed in the cluster, we can use the default API key for this tutorial.</p> <pre><code># secret.yaml\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: storage-minio\n  namespace: minio-tenant\nstringData:\n  AWS_ACCESS_KEY_ID: minio\n  AWS_SECRET_ACCESS_KEY: minio123\n</code></pre> <pre><code>kubectl apply -f secret.yaml\n</code></pre> <p>Finally, we can finish the setup for <code>provider-minio</code> by applying a <code>ProviderConfig</code> that references this secret.</p> <pre><code># minio-provider-config.yaml\n\napiVersion: minio.crossplane.io/v1\nkind: ProviderConfig\nmetadata:\n  name: storage-minio\n  namespace: crossplane-system\nspec:\n  credentials:\n    apiSecretRef:\n      name: storage-minio\n      namespace: minio-tenant\n    source: InjectedIdentity\n  minioURL: \"http://myminio-hl.minio-tenant.svc.cluster.local:9000/\"\n</code></pre> <pre><code>kubectl apply -f minio-provider-config.yaml\n</code></pre> <p>That's it for <code>provider-minio</code>.</p>"},{"location":"tutorials/storage-minio/#provider-kubernetes-configuration","title":"<code>provider-kubernetes</code> configuration","text":"<p>The second provider needed for <code>storage-minio</code> is <code>provider-kubernetes</code>. Since we want to observe <code>Policies</code> created by <code>provider-minio</code>, we need to create a <code>ServiceAccount</code> for <code>provider-kubernetes</code> that actually has permissions to observe these resources.</p> <p>The following file creates a <code>ServiceAccount</code>, <code>ClusterRole</code> and <code>ClusterRoleBinding</code> for those permissions.</p> <pre><code># rbac.yaml\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: storage-kubernetes\nrules:\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - objects\n      - objects/status\n      - observedobjectcollections\n      - observedobjectcollections/status\n      - providerconfigs\n      - providerconfigs/status\n      - providerconfigusages\n      - providerconfigusages/status\n    verbs:\n      - get\n      - list\n      - watch\n      - update\n      - patch\n      - create\n  - apiGroups:\n      - kubernetes.crossplane.io\n    resources:\n      - \"*/finalizers\"\n    verbs:\n      - update\n  - apiGroups:\n      - coordination.k8s.io\n    resources:\n      - secrets\n      - configmaps\n      - events\n      - leases\n    verbs:\n      - \"*\"\n  - apiGroups:\n      - minio.crossplane.io\n    resources:\n      - policies\n    verbs:\n      - watch\n      - get\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: storage-kubernetes\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: storage-kubernetes\nsubjects:\n  - kind: ServiceAccount\n    name: storage-kubernetes\n    namespace: crossplane-system\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: storage-kubernetes\n  namespace: crossplane-system\n</code></pre> <pre><code>kubectl apply -f rbac.yaml\n</code></pre> <p>Now we can update <code>provider-kubernetes</code> with a <code>DeploymentRuntimeConfig</code> to use this new <code>ServiceAccount</code>. Additionally, we provide the basic <code>ProviderConfig</code> needed by <code>provider-kubernetes</code>.</p> <pre><code># kubernetes-provider-config.yaml\n---\napiVersion: pkg.crossplane.io/v1\nkind: Provider\nmetadata:\n  name: crossplane-contrib-provider-kubernetes\nspec:\n  package: xpkg.crossplane.io/crossplane-contrib/provider-kubernetes:v0.18.0\n  runtimeConfigRef:\n    apiVersion: pkg.crossplane.io/v1beta1\n    kind: DeploymentRuntimeConfig\n    name: storage-kubernetes\n---\napiVersion: pkg.crossplane.io/v1beta1\nkind: DeploymentRuntimeConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  serviceAccountTemplate:\n    metadata:\n      name: storage-kubernetes\n---\napiVersion: kubernetes.crossplane.io/v1alpha1\nkind: ProviderConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  credentials:\n    source: InjectedIdentity\n</code></pre> <pre><code>kubectl apply -f kubernetes-provider-config.yaml\n</code></pre> <p>That's it for <code>provider-kubernetes</code> and the complete installation of <code>storage-minio</code>! Now we can finally create our first claim and see the configuration package in action!</p>"},{"location":"tutorials/storage-minio/#creating-buckets-for-alice-and-bob","title":"Creating <code>Buckets</code> for Alice and Bob","text":"<p>Everything is up and running and we can create our first claim - or rather, our first claims! Let's assume that, by default, we need two buckets for every user of the platform. Therefore, we create two two buckets named <code>alice</code> and <code>alice-shared</code> for the user \"Alice\" and <code>bob</code> and <code>bob-shared</code> for the user \"Bob\".</p> <pre><code># claims.yaml\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre>"},{"location":"tutorials/storage-minio/#requesting-access-to-buckets-from-bob","title":"Requesting access to <code>Buckets</code> from Bob","text":"<p>Now that everyone has their buckets, Alice wants to have access to <code>bob-shared</code> since both are working on a project together and she needs access to his results. Since Alice also needs to upload her results to that bucket she needs <code>ReadWrite</code> access.</p> <pre><code># claims.yaml\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre> <p>Note that the status of the <code>XStorage</code> object <code>alice-...</code> has changed to <code>READY: False</code> since the <code>alice.readwrite.bob-shared</code> policy does not exist yet and, therefore, cannot be attached to the user role.</p> <pre><code>kubectl get xstorages\n\n# Output\nNAME          SYNCED   READY   COMPOSITION        AGE\nalice-d7kbk   True     False   provider-storage   13m\nbob-2s79f     True     True    provider-storage   13m\n</code></pre> <pre><code>kubectl describe users.minio.crossplane.io alice\n\n# Output\nName:         alice\n...\nStatus:\n  At Provider:\n    Policies:   alice.owner.alice,alice.owner.alice-shared\n    Status:     enabled\n    User Name:  alice\n...\n</code></pre>"},{"location":"tutorials/storage-minio/#granting-access-to-buckets-to-alice","title":"Granting access to <code>Buckets</code> to Alice","text":"<p>Bob is the <code>owner</code> of <code>bob-shared</code> so he needs to grant Alice the <code>ReadWrite</code> permission to the bucket.</p> <pre><code># claims.yaml\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n  bucketAccessGrants:\n    - bucketName: bob-shared\n      permission: ReadWrite\n      grantees:\n        - alice\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre> <p>Note that it can take up to two minutes until the new policy is observed and synced. The status of the <code>XStorage</code> object has changed back to <code>READY: True</code> since the <code>alice.readwrite.bob-shared</code> policy has been created (Bob granted access to Alice) and is now attached to the user role.</p> <pre><code>kubectl get xstorages\n\n# Output\nNAME          SYNCED   READY   COMPOSITION        AGE\nalice-d7kbk   True     True    storage-minio      15m\nbob-2s79f     True     True    storage-minio      15m\n</code></pre> <pre><code>kubectl describe users.minio.crossplane.io alice\n\n# Output\nName:         alice\n...\nStatus:\n  At Provider:\n    Policies:   alice.owner.alice,alice.owner.alice-shared,alice.readwrite.bob-shared\n    Status:     enabled\n    User Name:  alice\n...\n</code></pre>"},{"location":"tutorials/storage-minio/#conclusion","title":"Conclusion","text":"<p>Congratulations! You have worked through the whole tutorial and have installed <code>storage-minio</code> and deployed your first claims. You should no be able to follow most of the How-to guides in the sidebar and look through the API definitions in the Reference guides and see what other options you can enable/disable in the claims.</p> <p>We are always happy about feedback and suggestions on how to improve the documentation or <code>provider-storage</code> as a whole. Therefore, if you have trouble following the tutorial or find errors please open an issue on GitHub and let us know about it!</p>"},{"location":"tutorials/storage-scaleway/","title":"Tutorials: storage-scaleway","text":"<p>These tutorials offer a series of steps to install, run and deploy your first <code>Claim</code> for the <code>storage-scaleway</code> configuration package. We are going to create buckets for Alice and Bob, two imaginary users. Then, Alice is going to request access to a bucket which is owned by Bob and in the last step Bob is going to grant access to Alice for this bucket.</p>"},{"location":"tutorials/storage-scaleway/#prerequisites","title":"Prerequisites","text":"<p>This tutorial assumes that you have go, kubectl and helm installed on your machine. Furthermore, we are using a local kind cluster for this tutorial. You can find installation instructions here.</p>"},{"location":"tutorials/storage-scaleway/#kind-cluster-and-crossplane-installation","title":"<code>kind</code> cluster and <code>crossplane</code> installation","text":"<p>After you have installed the necessary tools, we can create a new cluster with</p> <pre><code>kind create cluster --name storage-scaleway\n</code></pre> <p>and check if everything is working with</p> <pre><code>kubectl get pods -A\n</code></pre> <p>If the cluster is up and running, we need to install Crossplane. You can find more information about the installation process here.</p> <pre><code>helm repo add crossplane-stable https://charts.crossplane.io/stable\nhelm repo update\nhelm install crossplane \\\n--namespace crossplane-system \\\n--create-namespace crossplane-stable/crossplane \\\n--set provider.defaultActivations={} \\\n--set args={\"--enable-operations\"} \\\n--version 2.0.2\n</code></pre> <p>In order to reduce the strain on the control plane nodes, we also apply a ManagedResourceActivationPolicy and only activate the resources we need.</p> <pre><code># mrap.yaml\n\napiVersion: apiextensions.crossplane.io/v1alpha1\nkind: ManagedResourceActivationPolicy\nmetadata:\n  name: storage-scaleway\nspec:\n  activate:\n  - buckets.object.scaleway.upbound.io\n  - policies.object.scaleway.upbound.io\n  - apikeys.iam.scaleway.upbound.io\n  - applications.iam.scaleway.upbound.io\n  - policies.iam.scaleway.upbound.io\n</code></pre> <pre><code>kubectl apply -f mrap.yaml\n</code></pre>"},{"location":"tutorials/storage-scaleway/#storage-scaleway-configuration-package-installation","title":"<code>storage-scaleway</code> configuration package installation","text":"<p>In order to install the <code>storage-scaleway</code> configuration package, we first need to create a <code>Configuration</code>.</p> <pre><code># configuration.yaml\n\napiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-scaleway\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/scaleway:0.1-beta.3\n</code></pre> <p>Then, we need to apply it to the cluster with</p> <pre><code>kubectl apply -f configuration.yaml\n</code></pre> <p>This automatically installs the necessary dependencies specified in the configuration package:</p> <ul> <li>provider-scaleway: v0.4.0</li> <li>function-auto-ready: 0.5.0</li> <li>function-go-templating: v0.10.0</li> <li>function-python: v0.2.0</li> </ul> <p>You can check this by running</p> <pre><code>kubectl get pods -A\n</code></pre> <p>and confirm that you see pods name <code>crossplane-contrib-function-auto-ready-...</code>, <code>scaleway-provider-scaleway-...</code>, etc. Furthermore, you should now see one <code>CompositeResourceDefinition</code> or <code>XRD</code> and one <code>Composition</code> with</p> <pre><code>kubectl get xrds\nkubectl get compositions\n</code></pre> <p>The <code>storage-scaleway</code> configuration package is now installed. However, it is not functional yet since it does not install the necessary <code>ProviderConfig</code> and <code>Secret</code> that are needed by <code>provider-scaleway</code>.</p>"},{"location":"tutorials/storage-scaleway/#provider-scaleway-configuration","title":"<code>provider-scaleway</code> configuration","text":"<p>In order for the provider to know where to actually create the resources specified in the Crossplane composition, we need to provide it with connection details through a <code>ProviderConfig</code>.</p> <p>We need to create a <code>Secret</code> with the access keys for <code>provider-scaleway</code>.</p> <p>Copy the output of the above command into the secret and apply it to the cluster.</p> <pre><code># secret.yaml\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: storage-scaleway\n  namespace: crossplane-system\ntype: Opaque\nstringData:\n  credentials: |\n    {\n      \"access_key\": \"&lt;scaleway-access-key-id&gt;\",\n      \"secret_key\": \"&lt;scaleway-secret-access-key&gt;\",\n      \"organization_id\": \"&lt;scaleway-organization-id&gt;\",\n      \"user_id\": \"&lt;scaleway-user-id&gt;\",\n      \"region\": \"fr-par\",\n      \"zone\": \"fr-par-1\"\n    }\n</code></pre> <pre><code>kubectl apply -f secret.yaml\n</code></pre> <p>Warning</p> <p>In the README for <code>provider-scaleway</code>, the <code>user_id</code> is not present but it is essential for <code>storage-scaleway</code> to work! This is the user ID of the user/application associated with the <code>access_key</code>.</p> <p>Finally, we can finish the setup for <code>provider-scaleway</code>by applying a <code>ProviderConfig</code> that references this secret.</p> <pre><code># scaleway-provider-config.yaml\n\napiVersion: scaleway.upbound.io/v1beta1\nkind: ProviderConfig\nmetadata:\n  name: storage-scaleway\nspec:\n  credentials:\n    source: Secret\n    secretRef:\n      name: storage-scaleway\n      namespace: crossplane-system\n      key: credentials\n</code></pre> <pre><code>kubectl apply -f scaleway-provider-config.yaml\n</code></pre> <p>That's it for <code>provider-scaleway</code>.</p>"},{"location":"tutorials/storage-scaleway/#creating-buckets-for-alice-and-bob","title":"Creating <code>Buckets</code> for Alice and Bob","text":"<p>Everything is up and running and we can create our first claim - or rather, our first claims! Let's assume that, by default, we need two buckets for every user of the platform. Therefore, we create two two buckets named <code>alice</code> and <code>alice-shared</code> for the user \"Alice\" and <code>bob</code> and <code>bob-shared</code> for the user \"Bob\".</p> <pre><code># claims.yaml\n\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre>"},{"location":"tutorials/storage-scaleway/#requesting-access-to-buckets-from-bob","title":"Requesting access to <code>Buckets</code> from Bob","text":"<p>Now that everyone has their buckets, Alice wants to have access to <code>bob-shared</code> since both are working on a project together and she needs access to his results. Since Alice also needs to upload her results to that bucket she needs <code>ReadWrite</code> access.</p> <pre><code># claims.yaml\n\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre>"},{"location":"tutorials/storage-scaleway/#granting-access-to-buckets-to-alice","title":"Granting access to <code>Buckets</code> to Alice","text":"<p>Bob is the <code>owner</code> of <code>bob-shared</code> so he needs to grant Alice the <code>ReadWrite</code> permission to the bucket.</p> <pre><code># claims.yaml\n\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n  bucketAccessGrants:\n    - bucketName: bob-shared\n      permission: ReadWrite\n      grantees:\n        - alice\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre> <p>The <code>application_id</code> of <code>alice</code> is now attached to the policy.</p> <pre><code>kubectl describe policies.object.scaleway.upbound.io bob-shared\n\n# Output\nspec:\n  Deletion Policy:  Delete\n  For Provider:\n    Bucket:  storage-scaleway-bob-shared-p-s\n    Policy:  {\n  \"Version\": \"2023-04-17\",\n  \"Statement\": [\n  ...\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"SCW\": [\n          \"application_id:dcff9178-bc0b-4da6-87ea-6cccae757dec\"\n        ]\n      },\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\"\n      ],\n      \"Resource\": [\n        \"bob-bob-shared-abcde-fghij\",\n        \"bob-bob-shared-abcde-fghij/*\"\n      ]\n    }\n  ...\n</code></pre>"},{"location":"tutorials/storage-scaleway/#conclusion","title":"Conclusion","text":"<p>Congratulations! You have worked through the whole tutorial and have installed <code>storage-scaleway</code> and deployed your first claims. You should no be able to follow most of the How-to guides in the sidebar and look through the API definitions in the Reference guides and see what other options you can enable/disable in the claims.</p> <p>We are always happy about feedback and suggestions on how to improve the documentation or <code>provider-storage</code> as a whole. Therefore, if you have trouble following the tutorial or find errors please open an issue on GitHub and let us know about it!</p>"}]}