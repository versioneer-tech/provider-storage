{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Provider Storage","text":"<p>The Provider Storage package brings cloud-native, declarative storage management into your Kubernetes cluster, built on Crossplane v2. It gives end users a simple way to request and share S3 buckets, and it gives operators a consistent control plane to enforce policies across multiple backends such as MinIO, AWS S3, OTC OBS, and others.</p> <p>Instead of juggling credentials, APIs, and bucket lifecycles separately for each provider, everything is managed through a single Kubernetes Custom Resource: the <code>Storage</code> claim.  This claim captures a user\u2019s storage needs \u2014 create a bucket, request access to someone else\u2019s, or grant access to collaborators \u2014 while Crossplane and the compositions takes care of provisioning on the underlying backend.</p> <p>For end users, this means:</p> <ul> <li>Create personal or shared buckets with one manifest.  </li> <li>Request access to other buckets without having to ask operators directly.  </li> <li>Receive credentials automatically in a Kubernetes Secret.  </li> </ul> <p>For operators, this means:</p> <ul> <li>A unified model for managing storage across different S3-compatible systems.  </li> <li>Consistent enforcement of access policies and sharing rules.  </li> <li>Extensibility through Crossplane\u2019s composition model \u2014 adapt the backend without changing the user-facing API.  </li> </ul> <p>At its core, Provider Storage provides:</p> <ul> <li>A Storage Composite Resource Definition (XRD) </li> <li>Compositions to provision buckets, manage access, and reconcile credentials  </li> <li>Support for cross-user sharing and collaboration  </li> </ul>"},{"location":"#with-provider-storage-storage-becomes-declarative-multi-tenant-and-self-service-all-while-staying-under-operator-control","title":"With Provider Storage, storage becomes declarative, multi-tenant, and self-service, all while staying under operator control.","text":""},{"location":"#features","title":"Features","text":"<ul> <li>Multi-cloud support   Provision S3-compatible storage across MinIO, AWS, OTC, and others.</li> <li>Unified abstraction   Manage buckets, access grants, and requests through a single spec.  </li> <li>Cross-user sharing   Easily grant and request access to buckets across teams.  </li> <li>Kubernetes-native secrets   Automatically provisions S3-compatible credentials as Kubernetes Secrets.</li> <li>Extensible by design   Built on Crossplane, ready to extend with new resources.  </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the configuration package into your Crossplane empowered Kubernetes environment, use e.g. for MinIO: </p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-minio\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/minio:0.2.0\n  skipDependencyResolution: true\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#minimal-example","title":"Minimal Example","text":"<pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: team-wonderland\nspec:\n  principal: alice\n  buckets:\n    - bucketName: wonderland\n</code></pre> <p>This will provision a bucket named <code>wonderland</code>, along with the required cloud-specific entities such as IAM users, access credentials, and bucket policies granting bucket <code>ReadWrite</code> access to <code>alice</code></p> <p>Note</p> <p>All configuration packages derived from <code>provider-storage</code> expose the same <code>Storage</code> Composite Resource Definition (XRD). If multiple providers are installed, each <code>Storage</code> claim must be labeled to ensure it binds to the desired provider.</p> <p>For each <code>Storage</code> resource, a Secret is created in the same namespace, containing credentials for the selected backend.</p> <ul> <li>MinIO, AWS:  </li> <li><code>AWS_ACCESS_KEY_ID</code> </li> <li> <p><code>AWS_SECRET_ACCESS_KEY</code></p> </li> <li> <p>OTC:  </p> </li> <li><code>attribute.access</code> </li> <li><code>attribute.secret</code></li> </ul> <p>Use these secrets in your workloads to connect directly to the provisioned storage with standard S3 tooling, for example:</p> <pre><code>aws s3 ls s3://wonderland\n</code></pre>"},{"location":"#more-examples","title":"More Examples","text":"<p>Check the examples folder in the GitHub repository for complete scenarios, including:</p> <ul> <li>Storage claims with multiple buckets</li> <li>Cross-team access requests and grants</li> </ul>"},{"location":"how-to-guides/installation/","title":"Provider Storage \u2013 Installation Guide","text":"<p>The <code>provider-storage</code> configuration packages let you provision S3-compatible storage on MinIO, AWS S3, OTC OBS and others using Crossplane. Buckets, access policies, and cross-user sharing are declared via a single, namespaced <code>Storage</code> spec.</p>"},{"location":"how-to-guides/installation/#namespacing-model-important","title":"Namespacing Model (Important)","text":"<p>Everything in this guide is namespaced:</p> <ul> <li>You apply <code>Storage</code> claims to a namespace (e.g., <code>workspace</code>).</li> <li>The provisioned Secret lives in the same namespace as the <code>Storage</code> claim (Secret name = principal).</li> <li>Any namespaced ProviderConfigs or supporting objects that the compositions depend on must exist in that same target namespace (e.g., <code>workspace</code>).</li> </ul> <p>In short: choose your target namespace (e.g., <code>workspace</code>), apply the provider configs there, and create your <code>Storage</code> claims in that namespace.</p>"},{"location":"how-to-guides/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A running Kubernetes cluster (e.g., <code>kind</code>, managed K8s).</li> <li><code>kubectl</code> access.</li> <li>Crossplane installed in the cluster:</li> </ul> <pre><code>helm repo add crossplane-stable https://charts.crossplane.io/stable\nhelm repo update\nhelm install crossplane\n  --namespace crossplane-system\n  --create-namespace crossplane-stable/crossplane\n  --version 2.0.2\n  --set provider.defaultActivations={}\n</code></pre> <p>To reduce control-plane load, we use a <code>ManagedResourceActivationPolicy</code> (MRAP) per backend so only the needed Managed Resources are active.</p>"},{"location":"how-to-guides/installation/#step-1-install-provider-dependencies-per-backend","title":"Step 1 \u2013 Install Provider Dependencies (per backend)","text":"<p>All providers follow the same staged pattern you must install before the configuration package:</p> <ol> <li>ManagedResourceActivationPolicy \u2013 activate only the resource kinds that are needed.</li> <li>Deployment Runtime Configs \u2013 define how providers/functions run.</li> <li>Providers \u2013 install the required Crossplane providers.</li> <li>ProviderConfigs (namespaced) \u2013 point providers to endpoints/credentials in your target namespace.</li> <li>Functions \u2013 install supporting Crossplane Functions.</li> <li>RBAC \u2013 permissions for <code>provider-kubernetes</code> to observe and reconcile objects.</li> </ol> <p>Repository root: https://github.com/versioneer-tech/provider-storage/</p>"},{"location":"how-to-guides/installation/#minio","title":"MinIO","text":"<p>You operate a MinIO endpoint yourself (same/different cluster or DC). For a one-stop local dev on <code>kind</code>, see the guide around Local Setup.</p> <ul> <li>00-mrap.yaml \u2013 Activate MinIO-specific Managed Resources.</li> <li>01-deploymentRuntimeConfigs.yaml \u2013 Runtime configs for providers/functions.</li> <li>02-providers.yaml \u2013 Install <code>provider-minio</code> and <code>provider-kubernetes</code>.</li> <li>03-providerConfigs.yaml \u2013 Apply in your target namespace (e.g., <code>workspace</code>); points to your MinIO endpoint/credentials.</li> <li>functions.yaml \u2013 Functions used by compositions.</li> <li>rbac.yaml \u2013 RBAC for <code>provider-kubernetes</code>.</li> </ul>"},{"location":"how-to-guides/installation/#aws","title":"AWS","text":"<p>You provide endpoint configuration and credentials via a Secret referenced by a namespaced <code>ProviderConfig</code>.</p> <ul> <li>00-mrap.yaml \u2013 Activate AWS S3/IAM Managed Resources.</li> <li>01-deploymentRuntimeConfigs.yaml \u2013 Runtime configs for AWS + Kubernetes providers.</li> <li>02-providers.yaml \u2013 Install <code>provider-upjet-aws</code> and <code>provider-kubernetes</code>.</li> <li>03-providerConfigs.yaml \u2013 Apply in your target namespace; references AWS credentials Secret.</li> <li>functions.yaml \u2013 Functions used by compositions.</li> <li>rbac.yaml \u2013 RBAC for <code>provider-kubernetes</code>.</li> </ul>"},{"location":"how-to-guides/installation/#otc","title":"OTC","text":"<p>You do not deploy OBS; you provide OTC credentials via a Secret referenced by a namespaced <code>ProviderConfig</code>.</p> <ul> <li>00-mrap.yaml \u2013 Activate OTC Managed Resources.</li> <li>01-deploymentRuntimeConfigs.yaml \u2013 Runtime configs for OTC + Kubernetes providers.</li> <li>02-providers.yaml \u2013 Install OTC provider(s) and <code>provider-kubernetes</code>.</li> <li>03-providerConfigs.yaml \u2013 Apply in your target namespace; references OTC credentials Secret.</li> <li>functions.yaml \u2013 Functions used by compositions.</li> <li>rbac.yaml \u2013 RBAC for <code>provider-kubernetes</code>.</li> </ul>"},{"location":"how-to-guides/installation/#step-2-install-the-configuration-package-after-dependencies","title":"Step 2 \u2013 Install the Configuration Package (after dependencies)","text":"<p>Once the provider dependencies are in place, install the configuration package for your chosen backend. This registers the <code>Storage</code> CRD and compositions and allows immediate reconciliation because the providers/configs already exist.</p> <p>Example \u2013 MinIO</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-minio\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/minio:0.2.0\n</code></pre> <p>Example \u2013 AWS</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-aws\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/aws:0.2.0\n</code></pre> <p>Example \u2013 OTC</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-otc\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/otc:0.2.0\n</code></pre> <p>Apply your chosen one with:</p> <pre><code>kubectl apply -f configuration.yaml\n</code></pre>"},{"location":"how-to-guides/installation/#step-3-optional-quick-verification","title":"Step 3 \u2013 (Optional) Quick Verification","text":"<p>After the package installs and providers are healthy, you can create a minimal <code>Storage</code> claim in your target namespace and verify readiness and credentials. See the Usage &amp; Concepts guide for details (<code>kubectl get storages -n &lt;ns&gt;</code>, and inspect the Secret named after the principal).</p>"},{"location":"how-to-guides/local_setup/","title":"Provider Storage \u2013 Local Setup","text":"<p>This guide shows how to set up <code>provider-storage</code> locally using a kind cluster and a MinIO installation inside the cluster. It is intended for development, testing, and demonstrations.</p>"},{"location":"how-to-guides/local_setup/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have the following installed on your machine:</p> <ul> <li>Go (for some tooling)</li> <li>kubectl</li> <li>Helm</li> <li>kind</li> </ul>"},{"location":"how-to-guides/local_setup/#step-1-create-a-kind-cluster","title":"Step 1: Create a kind cluster","text":"<pre><code>kind create cluster --name storage-minio\nkubectl get pods -A\n</code></pre> <p>Verify that the cluster is up and running before proceeding.</p>"},{"location":"how-to-guides/local_setup/#step-2-install-crossplane","title":"Step 2: Install Crossplane","text":"<p>Install Crossplane into the cluster using Helm:</p> <pre><code>helm repo add crossplane-stable https://charts.crossplane.io/stable\nhelm repo update\nhelm install crossplane\n  --namespace crossplane-system\n  --create-namespace crossplane-stable/crossplane\n  --version 2.0.2 \n  --set provider.defaultActivations={}\n</code></pre> <p>Apply a <code>ManagedResourceActivationPolicy</code> (MRAP) to only activate the resources needed for MinIO:</p> <pre><code>apiVersion: apiextensions.crossplane.io/v1alpha1\nkind: ManagedResourceActivationPolicy\nmetadata:\n  name: storage-minio\nspec:\n  activate:\n  - buckets.minio.crossplane.io\n  - policies.minio.crossplane.io\n  - users.minio.crossplane.io\n  - objects.kubernetes.crossplane.io\n</code></pre> <pre><code>kubectl apply -f mrap.yaml\n</code></pre>"},{"location":"how-to-guides/local_setup/#step-3-install-minio-operator-and-tenant","title":"Step 3: Install MinIO Operator and Tenant","text":"<p>Install the MinIO Operator:</p> <pre><code>helm repo add minio-operator https://operator.min.io\nhelm install\n   --namespace minio-operator\n   --create-namespace operator minio-operator/operator\n</code></pre> <p>Create a small MinIO Tenant for testing. Save as <code>values.yaml</code>:</p> <pre><code>tenant:\n  pools:\n    - servers: 1\n      name: pool-0\n      volumesPerServer: 1\n      size: 1Gi\n  certificate:\n    requestAutoCert: false\n</code></pre> <p>Install the tenant:</p> <pre><code>helm install   --values values.yaml   --namespace minio-tenant   --create-namespace minio-tenant minio-operator/tenant\n</code></pre>"},{"location":"how-to-guides/local_setup/#step-4-install-provider-dependencies","title":"Step 4: Install Provider Dependencies","text":"<p>Apply the provider dependency files from the repo (in order):</p> <ul> <li>01-deploymentRuntimeConfigs.yaml </li> <li>02-providers.yaml </li> <li>03-providerConfigs.yaml (apply in your target namespace, e.g. <code>workspace</code>) </li> <li>functions.yaml </li> <li>rbac.yaml </li> </ul> <p>These configure the MinIO provider, Kubernetes provider, and required permissions.</p>"},{"location":"how-to-guides/local_setup/#step-5-install-the-configuration-package","title":"Step 5: Install the Configuration Package","text":"<p>Finally, install the configuration package for MinIO:</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-minio\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage/minio:0.2.0\n</code></pre> <pre><code>kubectl apply -f configuration.yaml\n</code></pre> <p>This installs the Crossplane <code>Storage</code> CRD and compositions.</p>"},{"location":"how-to-guides/local_setup/#step-6-create-a-storage-claim","title":"Step 6: Create a Storage Claim","text":"<p>With everything installed, create a <code>Storage</code> claim in your namespace (<code>workspace</code> is recommended):</p> <pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: team-wonderland\n  namespace: workspace\nspec:\n  principal: alice\n  buckets:\n    - bucketName: wonderland\n</code></pre>"},{"location":"how-to-guides/local_setup/#step-7-verify-the-setup","title":"Step 7: Verify the Setup","text":""},{"location":"how-to-guides/local_setup/#check-if-the-resource-is-ready","title":"Check if the resource is ready","text":"<pre><code>kubectl get storages -n workspace\n</code></pre> <p>Expected output:</p> <pre><code>NAME     SYNCED   READY   COMPOSITION        AGE\nteam-wonderland    True     True    storage-minio      2m\n</code></pre> <p>Inspect details:</p> <pre><code>kubectl describe storage team-wonderland -n workspace\n</code></pre>"},{"location":"how-to-guides/local_setup/#check-the-generated-secret","title":"Check the generated Secret","text":"<p>Each <code>Storage</code> claim produces a Secret with the principal\u2019s name in the same namespace. For example, the claim above creates a Secret <code>alice</code> in the <code>workspace</code> namespace.</p> <pre><code>kubectl get secret alice -n workspace -o yaml\n</code></pre> <p>Decode credentials if needed:</p> <pre><code>kubectl get secret alice -n workspace -o jsonpath='{.data.AWS_ACCESS_KEY_ID}' | base64 -d; echo\nkubectl get secret alice -n workspace -o jsonpath='{.data.AWS_SECRET_ACCESS_KEY}' | base64 -d; echo\n</code></pre>"},{"location":"how-to-guides/local_setup/#use-the-credentials","title":"Use the credentials","text":"<pre><code>aws s3 ls s3://alice   --endpoint-url http://minio-tenant-hl.minio-tenant.svc.cluster.local:9000\n</code></pre>"},{"location":"how-to-guides/local_setup/#summary","title":"Summary","text":"<ul> <li>A <code>kind</code> cluster with Crossplane is created.  </li> <li>MinIO Operator and Tenant provide the S3 backend.  </li> <li>Provider dependencies are installed first (providers, configs, RBAC).  </li> <li>The <code>storage-minio</code> configuration package registers the CRD and compositions.  </li> <li>A <code>Storage</code> claim provisions buckets and credentials.  </li> <li>A Secret (named after the principal) contains S3-compatible credentials usable with CLI tools.</li> </ul>"},{"location":"how-to-guides/permissions/","title":"Provider Storage \u2013 Permission Model","text":"<p>The permission model in <code>provider-storage</code> provides a consistent, backend-agnostic abstraction over the underlying IAM or policy mechanisms of MinIO, AWS, OTC, and others. Instead of exposing raw cloud-specific permission actions, permissions are normalized into four levels:</p> <ul> <li>ReadWrite \u2192 Full read and write access to bucket contents.   Includes: <code>ListBucket</code>, <code>GetObject</code>, <code>PutObject</code>, <code>DeleteObject</code> </li> <li>ReadOnly \u2192 View-only access.   Includes: <code>ListBucket</code>, <code>GetObject</code> </li> <li>WriteOnly \u2192 Append/write access without read visibility.   Includes: <code>ListBucket</code>, <code>PutObject</code>, <code>DeleteObject</code> </li> <li>None \u2192 Deny access (default when no permission is granted).</li> </ul>"},{"location":"how-to-guides/permissions/#discoverable-buckets","title":"Discoverable Buckets","text":"<p>A bucket must be marked as discoverable by its owner before others can request access. This is done by setting <code>discoverable: true</code> in the bucket definition of the owner\u2019s <code>Storage</code> claim.</p> <p>Example (owner Joe making his bucket discoverable):</p> <pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-joe\nspec:\n  principal: s-joe\n  buckets:\n    - bucketName: s-joe\n      discoverable: true\n</code></pre>"},{"location":"how-to-guides/permissions/#requesting-access","title":"Requesting Access","text":"<p>Other users can request access to a discoverable bucket by adding a <code>bucketAccessRequests</code> entry. Requests include the bucket name and optionally a reason or timestamp.</p> <p>Example (Jeff requesting access to Joe\u2019s bucket):</p> <pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-jeff\nspec:\n  principal: s-jeff\n  buckets:\n    - bucketName: s-jeff\n  bucketAccessRequests:\n    - bucketName: s-joe\n      reason: Need access for collaboration\n      requestedAt: \"2025-09-29T10:10:00Z\"\n</code></pre> <p>Until Joe explicitly grants access, Jeff\u2019s request remains pending.  </p>"},{"location":"how-to-guides/permissions/#granting-or-denying-access","title":"Granting or Denying Access","text":"<p>The bucket owner decides whether to grant or deny a request. This is captured with a <code>bucketAccessGrants</code> entry, which specifies:</p> <ul> <li>The bucket name  </li> <li>The grantee(s)  </li> <li>The granted permission (<code>ReadWrite</code>, <code>ReadOnly</code>, <code>WriteOnly</code>, or <code>None</code>)  </li> <li>The timestamp when the grant or denial was recorded (<code>grantedAt</code>)  </li> </ul> <p>Example (Joe granting Jeff ReadOnly access to <code>s-joe</code>):  </p> <pre><code>apiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-joe\nspec:\n  principal: s-joe\n  buckets:\n    - bucketName: s-joe\n      discoverable: true\n  bucketAccessGrants:\n    - bucketName: s-joe\n      grantee: s-jeff\n      permission: ReadOnly\n      grantedAt: \"2025-09-29T10:15:00Z\"\n</code></pre> <p>If Joe wanted to explicitly deny the request, he would set <code>permission: None</code> in the grant.</p>"},{"location":"how-to-guides/permissions/#lifecycle-of-a-permission","title":"Lifecycle of a Permission","text":"<ol> <li>Bucket owner marks bucket discoverable. </li> <li>Requester adds a <code>bucketAccessRequests</code> entry with desired permission.  </li> <li>Owner responds with a <code>bucketAccessGrants</code> entry. </li> <li>If permission is one of <code>ReadWrite</code>, <code>ReadOnly</code>, or <code>WriteOnly</code>, access is granted.  </li> <li>If permission is <code>None</code>, access is explicitly denied.  </li> <li>The system captures both the requestedAt and grantedAt timestamps for traceability.  </li> </ol> <p>This ensures a transparent workflow where requests, reasons, grants, and denials are all recorded in the claims.</p>"},{"location":"how-to-guides/permissions/#example-joe-and-jeff","title":"Example: Joe and Jeff","text":"<p>Joe shares his bucket, Jeff requests access, and Joe grants it:</p> <pre><code># Joe's claim\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-joe\nspec:\n  principal: s-joe\n  buckets:\n    - bucketName: s-joe\n      discoverable: true\n  bucketAccessGrants:\n    - bucketName: s-joe\n      grantee: s-jeff\n      permission: ReadOnly\n      grantedAt: \"2025-09-29T10:15:00Z\"\n---\n# Jeff's claim\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-jeff\nspec:\n  principal: s-jeff\n  buckets:\n    - bucketName: s-jeff\n  bucketAccessRequests:\n    - bucketName: s-joe\n      reason: Need read-only access for collaboration\n      requestedAt: \"2025-09-29T10:10:00Z\"\n</code></pre> <p>Outcome: - Jeff requested access to Joe\u2019s <code>s-joe</code>. - Joe granted it at a later time. - Both the request and grant are recorded declaratively.  </p>"},{"location":"how-to-guides/permissions/#summary","title":"Summary","text":"<ul> <li>The permission model is abstracted into ReadWrite, ReadOnly, WriteOnly, and None.  </li> <li>Owners must mark buckets discoverable for others to request access.  </li> <li>Access requests include the desired permission and an optional reason.  </li> <li>Owners grant or deny access explicitly, recorded with grantedAt and the resulting permission.  </li> <li>This workflow ensures transparency, auditability, and consistent handling across all storage backends.</li> </ul>"},{"location":"how-to-guides/usage_concepts/","title":"Provider Storage \u2013 Usage &amp; Concepts","text":"<p>This section explains how to use the <code>provider-storage</code> configuration packages once they are installed. It focuses on the concepts of Buckets, Access Requests, and Access Grants, and shows how to verify provisioning and access credentials.</p>"},{"location":"how-to-guides/usage_concepts/#concepts","title":"Concepts","text":""},{"location":"how-to-guides/usage_concepts/#credentials","title":"Credentials","text":"<p>For every <code>Storage</code> claim, access credentials are automatically created for the defined <code>principal</code> and provided as a Kubernetes Secret in the same namespace. Applications can directly consume this Secret to access the underlying object storage without any additional user management.</p> <p>Optionally, credentials can be automatically rolled over based on a configurable interval. A configurable history can be kept so that previous credentials remain valid for a period of overlap, avoiding disruptions for running workloads during key rotation.</p>"},{"location":"how-to-guides/usage_concepts/#buckets","title":"Buckets","text":"<p>A <code>Storage</code> claim defines one or more buckets for a user (the <code>principal</code>). Each bucket is created on the configured storage backend (MinIO, AWS S3, OTC OBS) and may optionally be marked discoverable so that others can see and request access for it.</p>"},{"location":"how-to-guides/usage_concepts/#access-requests","title":"Access Requests","text":"<p>A user may request access to another user\u2019s bucket. This is expressed in the <code>bucketAccessRequests</code> section of their <code>Storage</code> claim. Requests specify the target bucket and a free-text reason field.</p>"},{"location":"how-to-guides/usage_concepts/#access-grants","title":"Access Grants","text":"<p>The owner of a bucket can grant access to other users via the <code>bucketAccessGrants</code> section. A grant specifies the bucket, the grantee (user) and the permission \u2013 <code>ReadOnly</code>, <code>ReadWrite</code>, <code>WriteOnly</code>, or <code>None</code> in case of deny. A request only becomes effective once the corresponding grant is present.</p>"},{"location":"how-to-guides/usage_concepts/#example-joe-and-jeff","title":"Example: Joe and Jeff","text":""},{"location":"how-to-guides/usage_concepts/#joes-storage-definition","title":"Joe\u2019s Storage definition","text":"<pre><code># Joe creates one discoverable bucket s-joe, requests access to Jeff's bucket,\n# and grants Jeff ReadWrite access to s-joe.\n# Credentials are static, i.e. not automatically rolled over.\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-joe\nspec:\n  principal: s-joe\n  buckets:\n    - bucketName: s-joe\n      discoverable: true\n  bucketAccessRequests:\n    - bucketName: s-jeff-shared\n      reason: Need access\n      requestedAt: \"2025-09-29T10:00:00Z\"\n  bucketAccessGrants:\n    - bucketName: s-joe\n      grantee: s-jeff\n      permission: ReadWrite\n      grantedAt: \"2025-09-29T10:05:00Z\"\n</code></pre>"},{"location":"how-to-guides/usage_concepts/#jeffs-storage-definition","title":"Jeff\u2019s Storage definition","text":"<pre><code># Jeff creates two buckets, requests access to Joe's bucket,\n# and grants Joe ReadOnly access to one of his own buckets.\n# Credentials are automatically rolled over every week,\n# keeping the current plus the previous credential active.\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-jeff\nspec:\n  principal: s-jeff\n  credentialsRollover:\n    interval: weekly\n    maxToKeep: 2\n  buckets:\n    - bucketName: s-jeff\n    - bucketName: s-jeff-shared\n      discoverable: true\n  bucketAccessRequests:\n    - bucketName: s-joe\n      reason: Need access\n      requestedAt: \"2025-09-29T10:10:00Z\"\n  bucketAccessGrants:\n    - bucketName: s-jeff-shared\n      grantee: s-joe\n      permission: ReadOnly\n      grantedAt: \"2025-09-29T10:15:00Z\"\n</code></pre> <p>In this example:</p> <ul> <li>Joe owns <code>s-joe</code> and Jeff owns <code>s-jeff</code> and <code>s-jeff-shared</code>.</li> <li>Joe requests access to <code>s-jeff-shared</code>, Jeff requests access to <code>s-joe</code>.</li> <li>Joe grants Jeff ReadWrite access to <code>s-joe</code>.</li> <li>Jeff grants Joe ReadOnly access to <code>s-jeff-shared</code>.</li> </ul>"},{"location":"how-to-guides/usage_concepts/#example-jane-requesting-access-from-john","title":"Example: Jane requesting access from John","text":"<pre><code># Jane has no buckets but requests WriteOnly access to John's bucket.\n# Note: This request only becomes effective once John grants it.\n# Credentials are automatically rolled over every quarter,\n# keeping the current plus 4 previous credentials active.\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-jane\nspec:\n  principal: s-jane\n  credentialsRollover:\n    interval: quarterly\n    maxToKeep: 5\n  buckets: []\n  bucketAccessRequests:\n    - bucketName: s-john\n      reason: Need WriteOnly access\n      requestedAt: \"2025-09-29T10:20:00Z\"\n</code></pre> <p>This shows that a <code>Storage</code> claim may consist solely of access requests without creating any new buckets.</p>"},{"location":"how-to-guides/usage_concepts/#example-john-responding-to-jane","title":"Example: John responding to Jane","text":"<pre><code># John owns s-john. He grants Jane WriteOnly access to his bucket after her request.\n# His request to s-jane cannot resolve until that bucket exists.\n# Credentials are automatically rolled over every day.\napiVersion: pkg.internal/v1beta1\nkind: Storage\nmetadata:\n  name: s-john\nspec:\n  principal: s-john\n  credentialsRollover:\n    interval: daily\n  buckets:\n    - bucketName: s-john\n      discoverable: true\n  bucketAccessRequests:\n    - bucketName: s-joe\n      reason: Need access\n      requestedAt: \"2025-09-29T10:25:00Z\"\n    - bucketName: s-jeff\n      reason: Need access\n      requestedAt: \"2025-09-29T10:26:00Z\"\n    - bucketName: s-jane\n      reason: Need access\n      requestedAt: \"2025-09-29T10:27:00Z\"\n  bucketAccessGrants:\n    - bucketName: s-john\n      grantee: s-jane\n      permission: None\n      grantedAt: \"2025-09-29T10:28:00Z\"\n</code></pre> <p>In this scenario:</p> <ul> <li>Jane requests WriteOnly access to <code>s-john</code>.</li> <li>John grants it, so the request becomes effective.</li> <li>The system reconciles and attaches the effective permission.</li> </ul>"},{"location":"how-to-guides/usage_concepts/#verifying-provisioning","title":"Verifying Provisioning","text":"<p>Once a <code>Storage</code> claim has been applied, you can verify that the provisioning worked.</p>"},{"location":"how-to-guides/usage_concepts/#check-composite-status","title":"Check Composite Status","text":"<p>List all <code>storages</code> in your namespace (e.g., <code>workspace</code>):</p> <pre><code>kubectl get storages -n workspace\n</code></pre> <p>You should see <code>READY=True</code> once reconciliation is complete. Example:</p> <pre><code>NAME          SYNCED   READY   COMPOSITION        AGE\ns-jane        True     True    storage-minio      2m\ns-joe         True     True    storage-minio      2m\ns-jeff        True     True    storage-minio      2m\ns-john        True     True    storage-minio      2m\n</code></pre> <p>To see more detail, describe the composite:</p> <pre><code>kubectl describe storage s-joe -n workspace\n</code></pre> <p>Look for conditions like <code>Ready=True</code> and check any event messages.</p>"},{"location":"how-to-guides/usage_concepts/#find-the-secret-with-credentials","title":"Find the Secret with Credentials","text":"<p>Each <code>Storage</code> claim produces a Secret in the same namespace with the principal\u2019s name. For example, the claim <code>s-joe</code> with principal <code>joe</code> creates a Secret <code>joe</code>.</p> <p>List Secrets in the namespace:</p> <pre><code>kubectl get secrets -n workspace\n</code></pre> <p>Inspect the Secret:</p> <pre><code>kubectl describe secret joe -n workspace\n</code></pre> <p>View raw YAML (keys are base64-encoded):</p> <pre><code>kubectl get secret joe -n workspace -o yaml\n</code></pre> <p>Decode credentials locally, e.g. for AWS-style keys:</p> <pre><code>kubectl get secret joe -n workspace -o jsonpath='{.data.AWS_ACCESS_KEY_ID}' | base64 -d; echo\nkubectl get secret joe -n workspace -o jsonpath='{.data.AWS_SECRET_ACCESS_KEY}' | base64 -d; echo\n</code></pre> <p>Key names by provider: - MinIO / AWS: <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code> - OTC: <code>attribute.access</code>, <code>attribute.secret</code></p> <p>You can now use these credentials with any S3-compatible tool, e.g.:</p> <pre><code>aws s3 ls s3://s-joe\n</code></pre>"},{"location":"how-to-guides/usage_concepts/#summary","title":"Summary","text":"<ul> <li>A <code>Storage</code> claim defines buckets, access requests, and access grants.  </li> <li>Requests only take effect once the bucket owner provides a matching grant.  </li> <li>Every claim produces a Secret in the same namespace with the principal\u2019s name.  </li> <li>Check <code>kubectl get storages</code> for readiness and inspect the Secret for connection info.  </li> <li>Use the credentials directly with S3 tools or mount them into workloads.</li> </ul>"},{"location":"reference-guides/api/","title":"API Reference","text":"<p>Packages:</p> <ul> <li>pkg.internal/v1beta1</li> </ul>"},{"location":"reference-guides/api/#pkginternalv1beta1","title":"pkg.internal/v1beta1","text":"<p>Resource Types:</p> <ul> <li>Storage</li> </ul>"},{"location":"reference-guides/api/#storage","title":"Storage","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required apiVersion string pkg.internal/v1beta1 true kind string Storage true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object            Desired configuration of a Storage resource. Defines which buckets are created under the principal, which external buckets are requested, and which grants are issued to other principals.  false status object            Observed state of the Storage resource, including reconciliation results and any conditions applied by the controller.  false"},{"location":"reference-guides/api/#storagespec","title":"Storage.spec","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Desired configuration of a Storage resource. Defines which buckets are created under the principal, which external buckets are requested, and which grants are issued to other principals.</p> Name Type Description Required buckets []object            Buckets to create as part of this Storage. Each entry is keyed by bucketName, ensuring uniqueness within the resource. Ordering has no semantic meaning.  true principal string            Unique identifier of the storage principal (typically a user or service account). All buckets, access requests, and grants in this resource are owned and managed under this principal.  true bucketAccessGrants []object            Grants issued by this principal to other principals. Each grant is uniquely identified by bucketName and grantee and defines the permission level on the target bucket.  false bucketAccessRequests []object            Outbound requests for access to buckets owned by other principals. Each request originates from spec.principal and targets a single foreign bucket. The list is keyed by bucketName.  false credentialsRollover object            Configuration controlling automated rotation of access credentials issued for this storage principal.  false"},{"location":"reference-guides/api/#storagespecbucketsindex","title":"Storage.spec.buckets[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket to create. This value acts as the unique key for the list element.  true discoverable boolean            If true, the bucket is advertised for discovery by other principals. Defaults to false when omitted.  Default: false false"},{"location":"reference-guides/api/#storagespecbucketaccessgrantsindex","title":"Storage.spec.bucketAccessGrants[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket for which the permission is granted. This forms part of the unique key.  true grantedAt string            RFC3339 timestamp indicating when the grant became active. Used to track grant lifecycle. Typically set by the controller.  Format: date-time true grantee string            Identifier of the principal receiving the grant. This forms part of the unique key.  true permission enum            Permission level granted to the grantee on the specified bucket. Setting None explicitly removes access.  Enum: ReadWrite, ReadOnly, WriteOnly, None true"},{"location":"reference-guides/api/#storagespecbucketaccessrequestsindex","title":"Storage.spec.bucketAccessRequests[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket for which access is requested. This value is the unique key for the request.  true requestedAt string            RFC3339 timestamp indicating when the request was created. Used to track request lifecycle. Typically set by the controller.  Format: date-time true reason string            Optional free-text justification for the request. For informational and auditing purposes only.  false"},{"location":"reference-guides/api/#storagespeccredentialsrollover","title":"Storage.spec.credentialsRollover","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Configuration controlling automated rotation of access credentials issued for this storage principal.</p> Name Type Description Required interval enum            Defines how often access credentials are rotated. If set to none credentials are not rotated automatically.  Enum: daily, weekly, monthly, quarterly, yearly, none Default: none true maxToKeep integer            Maximum number of previous credentials that remain valid after a rollover. Older credentials beyond this limit are removed.  Default: 1 Minimum: 1 Maximum: 10 true"},{"location":"reference-guides/api/#storagestatus","title":"Storage.status","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Observed state of the Storage resource, including reconciliation results and any conditions applied by the controller.</p> Name Type Description Required"}]}