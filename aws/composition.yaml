# Copyright 2025, EOX (https://eox.at) and Versioneer (https://versioneer.at)
# SPDX-License-Identifier: Apache-2.0

apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: storage-aws
  labels:
    provider: aws
spec:
  compositeTypeRef:
    apiVersion: pkg.internal/v1beta1
    kind: Storage
  mode: Pipeline
  pipeline:
    - step: create-buckets
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format
          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))
          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              region = (spec.get("region") or "eu-central-1").strip()
              for b in (spec.get("buckets") or []):
                  bucket = (b.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  key = f"bucket-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "s3.aws.m.upbound.io/v1beta1",
                      "kind": "Bucket",
                      "metadata": {
                          "name": bucket,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {"region": region},
                          "providerConfigRef": {"name": "provider-aws", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-owner-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import json
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format
          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))
          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal>").strip()
              for b in (spec.get("buckets") or []):
                  bucket = (b.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  polname = f"{principal}.{bucket}"
                  policy_doc = {
                      "Version": "2012-10-17",
                      "Statement": [{
                          "Effect": "Allow",
                          "Action": ["s3:*"],
                          "Resource": [f"arn:aws:s3:::{bucket}", f"arn:aws:s3:::{bucket}/*"]
                      }]
                  }
                  key = f"policy-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "iam.aws.m.upbound.io/v1beta1",
                      "kind": "Policy",
                      "metadata": {
                          "name": polname,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {"policy": json.dumps(policy_doc, indent=2)},
                          "providerConfigRef": {"name": "provider-aws", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import json
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format
          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))
          def _policy_for(bucket, perm):
              p = (perm or "").strip().lower()
              if p == "readwrite":
                  stmts = [{
                      "Effect": "Allow",
                      "Action": ["s3:ListBucket","s3:GetObject","s3:PutObject","s3:DeleteObject"],
                      "Resource": [f"arn:aws:s3:::{bucket}", f"arn:aws:s3:::{bucket}/*"]
                  }]
              elif p == "readonly":
                  stmts = [
                      {"Effect":"Allow","Action":["s3:ListBucket"],"Resource":[f"arn:aws:s3:::{bucket}"]},
                      {"Effect":"Allow","Action":["s3:GetObject"],"Resource":[f"arn:aws:s3:::{bucket}/*"]}
                  ]
              elif p == "writeonly":
                  stmts = [
                      {"Effect":"Allow","Action":["s3:ListBucket"],"Resource":[f"arn:aws:s3:::{bucket}"]},
                      {"Effect":"Allow","Action":["s3:PutObject","s3:DeleteObject"],"Resource":[f"arn:aws:s3:::{bucket}/*"]}
                  ]
              else:
                  stmts = []
              return {"Version": "2012-10-17", "Statement": stmts}
          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              for g in (spec.get("bucketAccessGrants") or []):
                  bucket  = (g.get("bucketName") or "").strip()
                  grantee = (g.get("grantee") or "").strip()
                  perm    = (g.get("permission") or "").strip()
                  if not bucket or not grantee or not perm:
                      continue
                  policy_doc = _policy_for(bucket, perm)
                  pname = f"{grantee}.{bucket}"
                  key = f"policy-{grantee}-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "iam.aws.m.upbound.io/v1beta1",
                      "kind": "Policy",
                      "metadata": {
                          "name": pname,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {"policy": json.dumps(policy_doc, indent=2)},
                          "providerConfigRef": {"name": "provider-aws", "kind": "ProviderConfig"}
                      }
                  })

    - step: observe-requested-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format
          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))
          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal>").strip()
              for r in (spec.get("bucketAccessRequests") or []):
                  bucket = (r.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  polname = f"{principal}.{bucket}"
                  key = f"observe-{principal}-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "managementPolicies": ["Observe"],
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "iam.aws.m.upbound.io/v1beta1",
                                  "kind": "Policy",
                                  "metadata": {"name": polname, "namespace": ns}
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-users
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from datetime import datetime, timedelta, timezone
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format
          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def _get_rollover(spec: dict) -> tuple[str, int]:
              cfg = (spec.get("credentialsRollover") or {})
              interval = (cfg.get("interval") or "none").strip().lower()
              max_to_keep = cfg.get("maxToKeep")
              if max_to_keep is None:
                  max_to_keep = 1
              try:
                  max_to_keep = int(max_to_keep)
              except Exception:
                  max_to_keep = 1
              if max_to_keep < 1:
                  max_to_keep = 1
              if max_to_keep > 10:
                  max_to_keep = 10
              return interval, max_to_keep

          def _quarter(dt: datetime) -> int:
              return ((dt.month - 1) // 3) + 1

          def _suffixes(now: datetime, interval: str, max_to_keep: int) -> list[str]:
              out = []
              if interval == "daily":
                  for i in range(max_to_keep):
                      d = (now - timedelta(days=i)).date()
                      out.append(d.strftime("%Y%m%d"))
              elif interval == "weekly":
                  for i in range(max_to_keep):
                      d = (now - timedelta(weeks=i)).date()
                      iso = d.isocalendar()
                      out.append(f"{iso.year}w{iso.week:02d}")
              elif interval == "monthly":
                  for i in range(max_to_keep):
                      y = now.year
                      m = now.month - i
                      while m <= 0:
                          y -= 1
                          m += 12
                      out.append(f"{y}{m:02d}")
              elif interval == "quarterly":
                  for i in range(max_to_keep):
                      q_total = (now.year * 4 + (_quarter(now) - 1)) - i
                      y = q_total // 4
                      q = (q_total % 4) + 1
                      out.append(f"{y}q{q}")
              elif interval == "yearly":
                  for i in range(max_to_keep):
                      out.append(str(now.year - i))
              else:
                  for i in range(1, max_to_keep + 1):
                      out.append(str(i))
              return ["-" + s for s in out]

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal>").strip()

              interval, max_to_keep = _get_rollover(spec)
              now = datetime.now(timezone.utc)
              suffixes = _suffixes(now, interval, max_to_keep)

              for suf in suffixes:
                  user_name = f"{principal}{suf}"
                  key = f"user-{user_name}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "iam.aws.m.upbound.io/v1beta1",
                      "kind": "User",
                      "metadata": {
                          "name": user_name,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {},
                          "providerConfigRef": {"name": "provider-aws", "kind": "ProviderConfig"}
                      }
                  })

              current_user_name = f"{principal}{suffixes[0] if suffixes else '-1'}"
              obs_key = f"observe-secret-{principal}"
              rsp.desired.resources[obs_key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": obs_key,
                      "namespace": ns,
                      "annotations": {"crossplane.io/composition-resource-name": obs_key}
                  },
                  "spec": {
                      "managementPolicies": ["Observe"],
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "Secret",
                              "metadata": {"name": current_user_name, "namespace": ns}
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

    - step: attach-policies-to-users
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from datetime import datetime, timedelta, timezone
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def _get_rollover(spec: dict) -> tuple[str, int]:
              cfg = (spec.get("credentialsRollover") or {})
              interval = (cfg.get("interval") or "none").strip().lower()
              max_to_keep = cfg.get("maxToKeep")
              if max_to_keep is None:
                  max_to_keep = 1
              try:
                  max_to_keep = int(max_to_keep)
              except Exception:
                  max_to_keep = 1
              if max_to_keep < 1:
                  max_to_keep = 1
              if max_to_keep > 10:
                  max_to_keep = 10
              return interval, max_to_keep

          def _quarter(dt: datetime) -> int:
              return ((dt.month - 1) // 3) + 1

          def _suffixes(now: datetime, interval: str, max_to_keep: int) -> list[str]:
              out = []
              if interval == "daily":
                  for i in range(max_to_keep):
                      d = (now - timedelta(days=i)).date()
                      out.append(d.strftime("%Y%m%d"))
              elif interval == "weekly":
                  for i in range(max_to_keep):
                      d = (now - timedelta(weeks=i)).date()
                      iso = d.isocalendar()
                      out.append(f"{iso.year}w{iso.week:02d}")
              elif interval == "monthly":
                  for i in range(max_to_keep):
                      y = now.year
                      m = now.month - i
                      while m <= 0:
                          y -= 1
                          m += 12
                      out.append(f"{y}{m:02d}")
              elif interval == "quarterly":
                  for i in range(max_to_keep):
                      q_total = (now.year * 4 + (_quarter(now) - 1)) - i
                      y = q_total // 4
                      q = (q_total % 4) + 1
                      out.append(f"{y}q{q}")
              elif interval == "yearly":
                  for i in range(max_to_keep):
                      out.append(str(now.year - i))
              else:
                  for i in range(1, max_to_keep + 1):
                      out.append(str(i))
              return ["-" + s for s in out]

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal>").strip()

              interval, max_to_keep = _get_rollover(spec)
              now = datetime.now(timezone.utc)
              suffixes = _suffixes(now, interval, max_to_keep)
              user_names = [f"{principal}{suf}" for suf in suffixes] if suffixes else [f"{principal}-1"]

              observed = getattr(req.observed, "resources", {}) or {}

              for user_name in user_names:
                  for b in (spec.get("buckets") or []):
                      bucket = (b.get("bucketName") or "").strip()
                      if not bucket:
                          continue
                      polname = f"{principal}.{bucket}"
                      key = f"upa-own-{user_name}-{bucket}"
                      rsp.desired.resources[key].resource.update({
                          "apiVersion": "iam.aws.m.upbound.io/v1beta1",
                          "kind": "UserPolicyAttachment",
                          "metadata": {
                              "name": f"{user_name}.{bucket}.own",
                              "namespace": ns,
                              "annotations": {"crossplane.io/composition-resource-name": key}
                          },
                          "spec": {
                              "forProvider": {
                                  "userRef": {"name": user_name},
                                  "policyArnRef": {"name": polname}
                              },
                              "providerConfigRef": {"name": "provider-aws", "kind": "ProviderConfig"}
                          }
                      })

                  for r in (spec.get("bucketAccessRequests") or []):
                      bucket = (r.get("bucketName") or "").strip()
                      if not bucket:
                          continue
                      polname = f"{principal}.{bucket}"
                      obs_key = f"observe-{principal}-{bucket}"
                      oc = observed.get(obs_key)
                      exists = False
                      if oc and getattr(oc, "resource", None):
                          od = _to_dict(oc.resource)
                          st = (od.get("status") or {})
                          has_manifest = bool((st.get("atProvider") or {}).get("manifest"))
                          conds = st.get("conditions") or []
                          is_ready = any(c.get("type") == "Ready" and c.get("status") in ("True", True) for c in conds)
                          exists = has_manifest or is_ready
                      if not exists:
                          continue
                      key = f"upa-req-{user_name}-{bucket}"
                      rsp.desired.resources[key].resource.update({
                          "apiVersion": "iam.aws.m.upbound.io/v1beta1",
                          "kind": "UserPolicyAttachment",
                          "metadata": {
                              "name": f"{user_name}.{bucket}.req",
                              "namespace": ns,
                              "annotations": {"crossplane.io/composition-resource-name": key}
                          },
                          "spec": {
                              "forProvider": {
                                  "userRef": {"name": user_name},
                                  "policyArnRef": {"name": polname}
                              },
                              "providerConfigRef": {"name": "provider-aws", "kind": "ProviderConfig"}
                          }
                      })

    - step: create-user-access-keys
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from datetime import datetime, timedelta, timezone
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def _get_rollover(spec: dict) -> tuple[str, int]:
              cfg = (spec.get("credentialsRollover") or {})
              interval = (cfg.get("interval") or "none").strip().lower()
              max_to_keep = cfg.get("maxToKeep")
              if max_to_keep is None:
                  max_to_keep = 1
              try:
                  max_to_keep = int(max_to_keep)
              except Exception:
                  max_to_keep = 1
              if max_to_keep < 1:
                  max_to_keep = 1
              if max_to_keep > 10:
                  max_to_keep = 10
              return interval, max_to_keep

          def _quarter(dt: datetime) -> int:
              return ((dt.month - 1) // 3) + 1

          def _suffixes(now: datetime, interval: str, max_to_keep: int) -> list[str]:
              out = []
              if interval == "daily":
                  for i in range(max_to_keep):
                      d = (now - timedelta(days=i)).date()
                      out.append(d.strftime("%Y%m%d"))
              elif interval == "weekly":
                  for i in range(max_to_keep):
                      d = (now - timedelta(weeks=i)).date()
                      iso = d.isocalendar()
                      out.append(f"{iso.year}w{iso.week:02d}")
              elif interval == "monthly":
                  for i in range(max_to_keep):
                      y = now.year
                      m = now.month - i
                      while m <= 0:
                          y -= 1
                          m += 12
                      out.append(f"{y}{m:02d}")
              elif interval == "quarterly":
                  for i in range(max_to_keep):
                      q_total = (now.year * 4 + (_quarter(now) - 1)) - i
                      y = q_total // 4
                      q = (q_total % 4) + 1
                      out.append(f"{y}q{q}")
              elif interval == "yearly":
                  for i in range(max_to_keep):
                      out.append(str(now.year - i))
              else:
                  for i in range(1, max_to_keep + 1):
                      out.append(str(i))
              return ["-" + s for s in out]

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal>").strip()

              interval, max_to_keep = _get_rollover(spec)
              now = datetime.now(timezone.utc)
              suffixes = _suffixes(now, interval, max_to_keep)

              for suf in suffixes:
                  user_name = f"{principal}{suf}"
                  key = f"access-key-{user_name}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "iam.aws.m.upbound.io/v1beta1",
                      "kind": "AccessKey",
                      "metadata": {
                          "name": user_name,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {"userRef": {"name": user_name}},
                          "providerConfigRef": {"name": "provider-aws", "kind": "ProviderConfig"},
                          "writeConnectionSecretToRef": {"name": user_name, "namespace": ns}
                      }
                  })

    - step: manage-current-secret
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = (meta.get("labels", {}) or {}).get("crossplane.io/claim-namespace") or meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal-missing>").strip()

              observed_resources = getattr(req.observed, "resources", {}) or {}
              obs_key = f"observe-secret-{principal}"
              oc = observed_resources.get(obs_key)

              if not oc or not getattr(oc, "resource", None):
                  return

              od = _to_dict(oc.resource)
              st = (od.get("status") or {})
              manifest = ((st.get("atProvider") or {}).get("manifest") or {})
              data = manifest.get("data") or {}
              if not isinstance(data, dict) or not data:
                  return

              key = f"secret-{principal}"
              secret_name = f"{principal}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": key,
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "Secret",
                              "metadata": {
                                  "name": secret_name,
                                  "namespace": ns,
                              },
                              "type": "Opaque",
                              "data": data,
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

    - step: automatically-detect-ready-composed-resources
      functionRef:
        name: crossplane-contrib-function-auto-ready
