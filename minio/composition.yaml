# Copyright 2025, EOX (https://eox.at) and Versioneer (https://versioneer.at)
# SPDX-License-Identifier: Apache-2.0

apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: storage-minio
  labels:
    provider: minio
spec:
  compositeTypeRef:
    apiVersion: pkg.internal/v1beta1
    kind: Storage
  mode: Pipeline
  pipeline:
    - step: create-buckets
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr   = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = meta.get("namespace") or "default"

              for b in (spec.get("buckets") or []):
                  bucket = (b.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  discoverable = str(bool(b.get("discoverable", False))).lower()
                  key = f"bucket-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "minio.crossplane.io/v1",
                                  "kind": "Bucket",
                                  "metadata": {
                                      "name": bucket,
                                      "annotations": {"storages.pkg.internal/discoverable": discoverable}
                                  },
                                  "spec": {
                                      "providerConfigRef": {"name": "provider-minio"}
                                  }
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-principal-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import json
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr   = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal-missing>").strip()

              for b in (spec.get("buckets") or []):
                  bucket = (b.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  polname = f"{principal}.{bucket}"
                  key = f"policy-full-{bucket}"
                  raw = json.dumps({
                      "Version": "2012-10-17",
                      "Statement": [{
                          "Effect": "Allow",
                          "Action": ["s3:*"],
                          "Resource": [f"arn:aws:s3:::{bucket}", f"arn:aws:s3:::{bucket}/*"]
                      }]
                  }, indent=2)

                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "minio.crossplane.io/v1",
                                  "kind": "Policy",
                                  "metadata": {"name": polname},
                                  "spec": {
                                      "forProvider": {"rawPolicy": raw},
                                      "providerConfigRef": {"name": "provider-minio"}
                                  }
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import json
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def _raw_policy(bucket, perm):
              p = (perm or "").strip().lower()
              if p == "readwrite":
                  stmt = [{
                      "Effect": "Allow",
                      "Action": ["s3:GetBucketLocation","s3:ListBucket","s3:GetObject","s3:PutObject","s3:DeleteObject"],
                      "Resource": [f"arn:aws:s3:::{bucket}", f"arn:aws:s3:::{bucket}/*"]
                  }]
              elif p == "readonly":
                  stmt = [
                      {"Effect": "Allow","Action": ["s3:GetBucketLocation","s3:ListBucket"],"Resource": [f"arn:aws:s3:::{bucket}"]},
                      {"Effect": "Allow","Action": ["s3:GetObject"],"Resource": [f"arn:aws:s3:::{bucket}/*"]},
                  ]
              elif p == "writeonly":
                  stmt = [
                      {"Effect": "Allow","Action": ["s3:GetBucketLocation","s3:ListBucket"],"Resource": [f"arn:aws:s3:::{bucket}"]},
                      {"Effect": "Allow","Action": ["s3:PutObject","s3:DeleteObject"],"Resource": [f"arn:aws:s3:::{bucket}/*"]},
                  ]
              elif p == "none":
                  stmt = []
              else:
                  stmt = []
              return json.dumps({"Version": "2012-10-17","Statement": stmt}, indent=2)

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr   = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = meta.get("namespace") or "default"

              for grant in (spec.get("bucketAccessGrants") or []):
                  bucket  = (grant.get("bucketName") or "").strip()
                  grantee = (grant.get("grantee") or "").strip()
                  perm    = (grant.get("permission") or "").strip()
                  if not bucket or not grantee or not perm:
                      continue

                  raw = _raw_policy(bucket, perm)
                  polname = f"{grantee}.{bucket}"
                  key = f"policy-{grantee}-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "minio.crossplane.io/v1",
                                  "kind": "Policy",
                                  "metadata": {"name": polname},
                                  "spec": {
                                      "forProvider": {"rawPolicy": raw},
                                      "providerConfigRef": {"name": "provider-minio"}
                                  }
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: check-if-requested-policies-exist
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr   = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal-missing>").strip()

              for r in (spec.get("bucketAccessRequests") or []):
                  bucket = (r.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  polname = f"{principal}.{bucket}"
                  key = f"observe-{principal}-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "managementPolicies": ["Observe"],
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "minio.crossplane.io/v1",
                                  "kind": "Policy",
                                  "metadata": {"name": polname}
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-users-with-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import time

          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr   = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns   = meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "<principal-missing>").strip()

              policies = []
              for b in (spec.get("buckets") or []):
                  bucket = (b.get("bucketName") or "").strip()
                  if bucket:
                      policies.append(f"{principal}.{bucket}")

              observed_resources = getattr(req.observed, "resources", {}) or {}
              for r in (spec.get("bucketAccessRequests") or []):
                  bucket = (r.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  obs_key = f"observe-{principal}-{bucket}"
                  oc = observed_resources.get(obs_key)
                  exists = False
                  if oc and getattr(oc, "resource", None):
                      od = _to_dict(oc.resource)
                      st = (od.get("status") or {})
                      has_manifest = bool((st.get("atProvider") or {}).get("manifest"))
                      conds = st.get("conditions") or []
                      is_ready = any(c.get("type") == "Ready" and c.get("status") in ("True", True) for c in conds)
                      exists = has_manifest or is_ready
                  if exists:
                      policies.append(f"{principal}.{bucket}")

              user_1 = {
                  "name": f"{principal}-1",
                  "key": f"user-{principal}-1",
              }

              user_2 = {
                  "name": f"{principal}-2",
                  "key": f"user-{principal}-2",
              }

              for user in [user_1, user_2]:
                  key = user["key"]
                  user_name = user["name"]

                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {
                              "crossplane.io/composition-resource-name": key,
                          }
                      },
                      "spec": {
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "minio.crossplane.io/v1",
                                  "kind": "User",
                                  "metadata": {
                                      "name": user_name,
                                  },
                                  "spec": {
                                      "forProvider": {"userName": user_name, "policies": policies},
                                      "providerConfigRef": {"name": "provider-minio"},
                                      "writeConnectionSecretToRef": {"name": user_name, "namespace": ns}
                                  }
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-eso-rbac
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import time

          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr   = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              ns   = meta.get("namespace") or "default"
              principal = (meta.get("name") or "default").strip()

              sa_name = f"eso-sa-{principal}"
              r_name = f"eso-r-{principal}"
              rb_name = f"eso-rb-{principal}"
              secret_store_name = f"secret-store-{principal}"

              rsp.desired.resources[sa_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": sa_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": sa_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "ServiceAccount",
                              "metadata": {"name": "eso-store", "namespace": ns}
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

              rsp.desired.resources[r_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": r_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": r_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "rbac.authorization.k8s.io/v1",
                              "kind": "Role",
                               "metadata": {"name": "eso-store-reader", "namespace": ns},
                                "rules": [
                                   {"apiGroups": [""], "resources": ["secrets"], "verbs": ["get", "list", "watch"]},
                                   {"apiGroups": ["authorization.k8s.io"], "resources": ["selfsubjectrulesreviews"], "verbs": ["create"]}
                                 ]
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

              rsp.desired.resources[rb_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": rb_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": rb_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "rbac.authorization.k8s.io/v1",
                              "kind": "RoleBinding",
                              "metadata": {"name": "eso-store-reader-binding", "namespace": ns},
                              "subjects": [{"kind": "ServiceAccount", "name": "eso-store", "namespace": ns}],
                              "roleRef": {"kind": "Role", "name": "eso-store-reader", "apiGroup": "rbac.authorization.k8s.io"}
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

              rsp.desired.resources[secret_store_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": secret_store_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": secret_store_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "external-secrets.io/v1",
                              "kind": "SecretStore",
                              "metadata": {"name": "store", "namespace": ns},
                              "spec": {
                                  "provider": {
                                      "kubernetes": {
                                          "remoteNamespace": ns,
                                          "server": {
                                              "caProvider": {"type": "ConfigMap", "name": "kube-root-ca.crt", "key": "ca.crt"}
                                          },
                                          "auth": {"serviceAccount": {"name": "eso-store"}}
                                      }
                                  }
                              }
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

    - step: create-eso-job
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import time

          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def _to_dict(struct):
              return {} if struct is None else (struct if isinstance(struct, dict) else json_format.MessageToDict(struct, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = _to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              ns = meta.get("namespace") or "default"
              principal = (meta.get("name") or "default").strip()

              sa_name = f"job-sa-{principal}"
              r_name = f"job-r-{principal}"
              rb_name = f"job-rb-{principal}"
              job_name = f"external-secret-{principal}"

              rsp.desired.resources[sa_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": sa_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": sa_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "v1",
                              "kind": "ServiceAccount",
                              "metadata": {"name": sa_name, "namespace": ns}
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

              rsp.desired.resources[r_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": r_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": r_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "rbac.authorization.k8s.io/v1",
                              "kind": "Role",
                              "metadata": {
                                  "name": r_name,
                                  "namespace": ns
                              },
                              "rules": [{
                                  "apiGroups": ["external-secrets.io"],
                                  "resources": ["externalsecrets"],
                                  "verbs": ["create", "get", "list", "patch", "delete"]
                              }]
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })


              rsp.desired.resources[rb_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": rb_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": rb_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "rbac.authorization.k8s.io/v1",
                              "kind": "RoleBinding",
                              "metadata": {"name": rb_name, "namespace": ns},
                              "subjects": [{"kind": "ServiceAccount", "name": sa_name, "namespace": ns}],
                              "roleRef": {
                                  "kind": "Role", 
                                  "name": r_name, 
                                  "apiGroup": "rbac.authorization.k8s.io"
                              }
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

              external_secret_manifest = f"""
          apiVersion: external-secrets.io/v1
          kind: ExternalSecret
          metadata:
            name: {principal}
            namespace: {ns}
          spec:
            refreshInterval: 5m
            secretStoreRef:
              kind: SecretStore
              name: store
            target:
              name: {principal}
              creationPolicy: Owner
            data:
              - secretKey: AWS_ACCESS_KEY_ID
                remoteRef:
                  key: {principal}-1
                  property: AWS_ACCESS_KEY_ID
              - secretKey: AWS_SECRET_ACCESS_KEY
                remoteRef:
                  key: {principal}-1
                  property: AWS_SECRET_ACCESS_KEY
          """

              rsp.desired.resources[job_name].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": job_name,
                      "namespace": ns,
                      "annotations": {
                          "crossplane.io/composition-resource-name": job_name
                      }
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "batch/v1",
                              "kind": "Job",
                              "metadata": {"name": job_name, "namespace": ns},
                              "spec": {
                                  "template": {
                                      "spec": {
                                          "serviceAccountName": sa_name,
                                          "restartPolicy": "OnFailure",
                                          "containers": [{
                                              "name": "external-secret-job",
                                              "image": "bitnami/kubectl",
                                              "command": ["/bin/bash", "-c"],
                                              "args": [f"kubectl apply -f - <<EOF\n{external_secret_manifest}\nEOF"]
                                          }]
                                      }
                                  }
                              }
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
          })

    - step: automatically-detect-ready-composed-resources
      functionRef:
        name: crossplane-contrib-function-auto-ready
