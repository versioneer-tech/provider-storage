apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: storage-otc
  labels:
    provider: otc
spec:
  compositeTypeRef:
    apiVersion: pkg.internal/v1beta1
    kind: Storage
  mode: Pipeline
  pipeline:
    - step: create-user
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def to_dict(x):
              return {} if x is None else (x if isinstance(x, dict) else json_format.MessageToDict(x, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              principal = (spec.get("principal") or meta.get("name") or "").strip()
              ns = meta.get("namespace") or "default"
              if not principal:
                  return
              key = f"user-{principal}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": ns,
                      "annotations": {"crossplane.io/composition-resource-name": key}
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "identity.opentelekomcloud.crossplane.io/v1alpha1",
                              "kind": "UserV3",
                              "metadata": {"name": principal},
                              "spec": {
                                  "forProvider": {"name": principal, "enabled": True},
                                  "providerConfigRef": {"name": "provider-otc"}
                              }
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

    - step: observe-credential-and-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def to_dict(x):
              return {} if x is None else (x if isinstance(x, dict) else json_format.MessageToDict(x, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "").strip()
              if not principal:
                  return

              cred_name = f"aksk-{principal}"
              key = f"observe-credential-{principal}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": ns,
                      "annotations": {"crossplane.io/composition-resource-name": key}
                  },
                  "spec": {
                      "managementPolicies": ["Observe"],
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "identity.opentelekomcloud.crossplane.io/v1alpha1",
                              "kind": "CredentialV3",
                              "metadata": {"name": cred_name}
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

              for b in (spec.get("buckets") or []):
                  bucket = (b.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  pol_name = f"bucketpolicy-{bucket}"
                  key = f"observe-bucketpolicy-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "managementPolicies": ["Observe"],
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "obs.opentelekomcloud.crossplane.io/v1alpha1",
                                  "kind": "BucketPolicy",
                                  "metadata": {"name": pol_name}
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

              grantees = []
              for g in (spec.get("bucketAccessGrants") or []):
                  gr = (g.get("grantee") or "").strip()
                  if gr and gr not in grantees:
                      grantees.append(gr)

              for gr in grantees:
                  key = f"observe-user-{gr}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "managementPolicies": ["Observe"],
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "identity.opentelekomcloud.crossplane.io/v1alpha1",
                                  "kind": "UserV3",
                                  "metadata": {"name": gr}
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-buckets
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def to_dict(x):
              return {} if x is None else (x if isinstance(x, dict) else json_format.MessageToDict(x, preserving_proto_field_name=True))

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = meta.get("namespace") or "default"
              region = (spec.get("region") or "eu-nl").strip()
              for b in (spec.get("buckets") or []):
                  bucket = (b.get("bucketName") or "").strip()
                  if not bucket:
                      continue
                  key = f"bucket-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "obs.opentelekomcloud.crossplane.io/v1alpha1",
                                  "kind": "Bucket",
                                  "metadata": {"name": bucket},
                                  "spec": {
                                      "forProvider": {"bucket": bucket, "region": region},
                                      "providerConfigRef": {"name": "provider-otc"}
                                  }
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: create-access-key
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def to_dict(x):
              return {} if x is None else (x if isinstance(x, dict) else json_format.MessageToDict(x, preserving_proto_field_name=True))

          def dig(d, *keys):
              cur = d
              for k in keys:
                  if not isinstance(cur, dict):
                      return None
                  cur = cur.get(k)
              return cur

          def extract_ids(obj_dict):
              s = obj_dict.get("status") or {}
              ap = s.get("atProvider") or {}
              u = dig(ap, "manifest", "status", "atProvider") or {}
              if u.get("id"):
                  return u.get("id"), u.get("domainId")
              u = dig(ap, "manifest", "status") or {}
              if u and u.get("id"):
                  return u.get("id"), u.get("domainId")
              if ap.get("id"):
                  return ap.get("id"), ap.get("domainId")
              return None, None

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "").strip()
              if not principal:
                  return
              observed = getattr(req.observed, "resources", {}) or {}
              wrapper = observed.get(f"user-{principal}")
              user_id = None
              if wrapper and getattr(wrapper, "resource", None):
                  od = to_dict(wrapper.resource)
                  user_id, _ = extract_ids(od)
              if not user_id:
                  return
              key = f"access-key-{principal}"
              rsp.desired.resources[key].resource.update({
                  "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                  "kind": "Object",
                  "metadata": {
                      "name": key,
                      "namespace": ns,
                      "annotations": {"crossplane.io/composition-resource-name": key}
                  },
                  "spec": {
                      "forProvider": {
                          "manifest": {
                              "apiVersion": "identity.opentelekomcloud.crossplane.io/v1alpha1",
                              "kind": "CredentialV3",
                              "metadata": {"name": f"aksk-{principal}"},
                              "spec": {
                                  "forProvider": {"type": "AK", "userId": user_id},
                                  "providerConfigRef": {"name": "provider-otc"},
                                  "writeConnectionSecretToRef": {"name": principal, "namespace": ns}
                              }
                          }
                      },
                      "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                  }
              })

    - step: create-bucket-policies
      functionRef:
        name: crossplane-contrib-function-python
      input:
        apiVersion: python.fn.crossplane.io/v1beta1
        kind: Script
        script: |
          import json
          from collections import defaultdict
          from crossplane.function.proto.v1 import run_function_pb2 as fnv1
          from google.protobuf import json_format

          def to_dict(x):
              return {} if x is None else (x if isinstance(x, dict) else json_format.MessageToDict(x, preserving_proto_field_name=True))

          def dig(d, *keys):
              cur = d
              for k in keys:
                  if not isinstance(cur, dict):
                      return None
                  cur = cur.get(k)
              return cur

          def extract_ids(obj_dict):
              s = obj_dict.get("status") or {}
              ap = s.get("atProvider") or {}
              u = dig(ap, "manifest", "status", "atProvider") or {}
              if u.get("id"):
                  return u.get("id"), u.get("domainId")
              u = dig(ap, "manifest", "status") or {}
              if u and u.get("id"):
                  return u.get("id"), u.get("domainId")
              if ap.get("id"):
                  return ap.get("id"), ap.get("domainId")
              return None, None

          def grant_statements(bucket, principal_str, perm):
              p = (perm or "").strip().lower()
              if p == "readwrite":
                  bucket_actions = ["ListBucket"]; object_actions = ["GetObject", "PutObject", "DeleteObject"]
              elif p == "readonly":
                  bucket_actions = ["ListBucket"]; object_actions = ["GetObject"]
              elif p == "writeonly":
                  bucket_actions = ["ListBucket"]; object_actions = ["PutObject", "DeleteObject"]
              else:
                  bucket_actions = []; object_actions = []
              stmts = []
              if bucket_actions:
                  stmts.append({"Effect": "Allow", "Action": bucket_actions, "Resource": [f"{bucket}"], "Principal": {"ID": [principal_str]}})
              if object_actions:
                  stmts.append({"Effect": "Allow", "Action": object_actions, "Resource": [f"{bucket}/*"], "Principal": {"ID": [principal_str]}})
              return stmts

          def compose(req: fnv1.RunFunctionRequest, rsp: fnv1.RunFunctionResponse):
              xr = to_dict(req.observed.composite.resource)
              meta = xr.get("metadata", {}) or {}
              spec = xr.get("spec", {}) or {}
              ns = meta.get("namespace") or "default"
              principal = (spec.get("principal") or meta.get("name") or "").strip()
              if not principal:
                  return

              observed = getattr(req.observed, "resources", {}) or {}

              owner_wrapper = observed.get(f"user-{principal}")
              owner_id = owner_domain = None
              if owner_wrapper and getattr(owner_wrapper, "resource", None):
                  od = to_dict(owner_wrapper.resource)
                  owner_id, owner_domain = extract_ids(od)

              grantee_ids = {}
              for k, v in (observed or {}).items():
                  if not k.startswith("observe-user-"):
                      continue
                  if not getattr(v, "resource", None):
                      continue
                  gr_name = k.replace("observe-user-", "", 1)
                  od = to_dict(v.resource)
                  gid, gdom = extract_ids(od)
                  if gid:
                      grantee_ids[gr_name] = (gid, gdom)

              by_bucket = defaultdict(set)

              owned = [(b.get("bucketName") or "").strip() for b in (spec.get("buckets") or []) if (b.get("bucketName") or "").strip()]
              if owner_id and owner_domain:
                  owner_principal = f"domain/{owner_domain}:user/{owner_id}"
                  for bucket in owned:
                      by_bucket[bucket].add((owner_principal, "readwrite"))

              for g in (spec.get("bucketAccessGrants") or []):
                  bucket = (g.get("bucketName") or "").strip()
                  gr = (g.get("grantee") or "").strip()
                  perm = (g.get("permission") or "").strip()
                  if not bucket or not gr or not perm:
                      continue
                  ids = grantee_ids.get(gr)
                  if not ids:
                      continue
                  gid, gdom = ids
                  principal_str = f"domain/{gdom}:user/{gid}" if gdom else f"user/{gid}"
                  by_bucket[bucket].add((principal_str, perm))

              for bucket, items in by_bucket.items():
                  statements = []
                  for principal_str, perm in sorted(items):
                      statements.extend(grant_statements(bucket, principal_str, perm))
                  policy = {"Version": "2012-10-17", "Statement": statements}
                  key = f"bucketpolicy-{bucket}"
                  rsp.desired.resources[key].resource.update({
                      "apiVersion": "kubernetes.m.crossplane.io/v1alpha1",
                      "kind": "Object",
                      "metadata": {
                          "name": key,
                          "namespace": ns,
                          "annotations": {"crossplane.io/composition-resource-name": key}
                      },
                      "spec": {
                          "forProvider": {
                              "manifest": {
                                  "apiVersion": "obs.opentelekomcloud.crossplane.io/v1alpha1",
                                  "kind": "BucketPolicy",
                                  "metadata": {"name": f"bucketpolicy-{bucket}"},
                                  "spec": {
                                      "forProvider": {"bucket": bucket, "policy": json.dumps(policy, indent=2)},
                                      "providerConfigRef": {"name": "provider-otc"}
                                  }
                              }
                          },
                          "providerConfigRef": {"name": "provider-kubernetes", "kind": "ProviderConfig"}
                      }
                  })

    - step: automatically-detect-ready-composed-resources
      functionRef:
        name: crossplane-contrib-function-auto-ready
