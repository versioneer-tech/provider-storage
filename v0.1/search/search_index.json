{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"provider-storage","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The <code>provider-storage</code> Configuration Package is the root project for a collection of different configuration packages that enable the creation of S3-compatible object storage called <code>buckets</code> or <code>containers</code> as well as the possibility to request access from or grant access to those <code>buckets</code>.</p> <p>The following configuration packages are built from <code>provider-storage</code>:</p> <ul> <li><code>storage-minio</code></li> </ul>"},{"location":"#first-steps","title":"First steps","text":"<p>Before you can work with any of the configuration packages built from <code>provider-storage</code> you need to install Crossplane into your Kubernetes cluster. An easy way to start testing the configuration package is on a local kind cluster.</p> <p>You can either follow a tutorial to set up everything from scratch to deploy your first Claim or, if you already have experience with Crossplane and Kubernetes, follow a how-to guide on how to install a specific configuration package built from <code>providers-storage</code>.</p>"},{"location":"#getting-help","title":"Getting help","text":""},{"location":"#how-the-documentation-is-organized","title":"How the documentation is organized","text":"<p>The documentation is organized in four distinct parts:</p> <ul> <li>Tutorials invite you to follow a series of steps to install, run and deploy your first Claim for each configuration package.</li> <li>How-to guides are more advanced than tutorials and guide you through specific problems and use-cases.</li> <li>Reference guides contain the API definitions for the Composite Resource Definitions of the configuration packages.</li> <li>Discussions provide some insight in the inner workings of the Compositions and some reasoning behind their implementation.</li> </ul> <p>Note</p> <p>All configuration packages built from <code>provider-storage</code> share the same Composite Resource Definition!</p>"},{"location":"how-to-guides/storage-minio/","title":"How-to guides: storage-minio","text":"<p>The <code>storage-minio</code> configuration package allows the creation of <code>buckets</code> on a MinIO backend and automatically creates Policies for permission control. Furthermore, <code>storage-minio</code> includes a workflow to request/grant access to <code>buckets</code> from other <code>owners</code>.</p>"},{"location":"how-to-guides/storage-minio/#how-to-guides","title":"How-to guides","text":"<ul> <li>How to install the <code>storage-minio</code> configuration package</li> <li>How to create <code>Buckets</code> with <code>storage-minio</code></li> <li>How to request access to <code>Buckets</code> from other <code>owners</code></li> <li>How to grant access to <code>Buckets</code> to other <code>owners</code></li> </ul>"},{"location":"how-to-guides/storage-minio/#how-to-install-the-storage-minio-configuration-package","title":"How to install the <code>storage-minio</code> configuration package","text":"<p>The <code>storage-minio</code> configuration package can be installed like any other configuration package with</p> <pre><code>apiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-minio\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage:v0.1-minio\n</code></pre> <p>This automatically installs the necessary dependencies:</p> <ul> <li>provider-minio &gt;= v0.4.4</li> <li>provider-kubernetes &gt;= v0.18.0</li> <li>function-auto-ready &gt;= 0.5.0</li> <li>function-go-templating &gt;= v0.10.0</li> </ul> <p>However, it does not install the necessary <code>ProviderConfigs</code>, <code>ServiceAccounts</code> and <code>Secrets</code> that are actually needed for the <code>storage-minio</code> to work.</p> <p>The <code>provider-minio</code> needs to know how to access the MinIO instance and also needs credentials for it. Therefore, it needs a <code>Secret</code> which includes the access key and secret key.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nstringData:\n  AWS_ACCESS_KEY_ID: &lt;Access Key&gt;\n  AWS_SECRET_ACCESS_KEY: &lt;Secret Key&gt;\n</code></pre> <p>Furthermore, the <code>ProviderConfig</code> needs to reference this secret and also provide the URL for the MinIO instance.</p> <p>Warning</p> <p>The name of the <code>ProviderConfig</code> needs to be <code>storage-minio</code>! The composition will not work with any other name and will not be able to create resources!</p> <pre><code>apiVersion: minio.crossplane.io/v1\nkind: ProviderConfig\nmetadata:\n  name: storage-minio\n  namespace: crossplane-system\nspec:\n  credentials:\n    apiSecretRef:\n      name: &lt;secretName&gt;\n      namespace: &lt;secretNamespace&gt;\n    source: InjectedIdentity\n  minioURL: &lt;url&gt;\n</code></pre> <p>The <code>provider-kubernetes</code> needs a <code>ServiceAccount</code> that can observe resources from <code>policies.minio.crossplane.io</code>. Below is an example <code>ClusterRole</code> which expands the default <code>ClusterRole</code> created by <code>crossplane-rbac</code>.</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: &lt;name&gt;\nrules:\n- apiGroups:\n  - kubernetes.crossplane.io\n  resources:\n  - objects\n  - objects/status\n  - observedobjectcollections\n  - observedobjectcollections/status\n  - providerconfigs\n  - providerconfigs/status\n  - providerconfigusages\n  - providerconfigusages/status\n  verbs:\n  - get\n  - list\n  - watch\n  - update\n  - patch\n  - create\n- apiGroups:\n  - kubernetes.crossplane.io\n  resources:\n  - '*/finalizers'\n  verbs:\n  - update\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - secrets\n  - configmaps\n  - events\n  - leases\n  verbs:\n  - '*'\n- apiGroups:\n  - minio.crossplane.io\n  resources:\n  - policies\n  verbs:\n  - watch\n  - get\n</code></pre> <p>When the <code>ClusterRole</code> is attached to the <code>ServiceAccount</code> via a <code>ClusterRoleBinding</code>, the actual <code>provider-kubernetes</code> can be updated with a <code>DeploymentRuntimeConfig</code> to use the newly created <code>ServiceAccount</code>. Furthermore, a standard <code>ProviderConfig</code> can be applied.</p> <p>Warning</p> <p>Make sure that the <code>name</code> and version of the <code>Provider</code> matches the name of the Kubernetes provider that is already installed in your cluster! If it does not match, <code>crossplane</code> installs a new Kubernetes provider with the given name. The standard name is <code>crossplane-contrib-provider-kubernetes</code> if the provider was installed as part of the dependencies in the configuration package.</p> <p>Warning</p> <p>The name of the <code>ProviderConfig</code> needs to be <code>storage-kubernetes</code>! The composition will not work with any other name and will not be able to observe resources!</p> <pre><code>\n---\napiVersion: pkg.crossplane.io/v1\nkind: Provider\nmetadata:\n  name: &lt;name&gt;\nspec:\n  package: xpkg.upbound.io/crossplane-contrib/provider-kubernetes:&lt;version&gt;\n  runtimeConfigRef:\n    apiVersion: pkg.crossplane.io/v1beta1\n    kind: DeploymentRuntimeConfig\n    name: &lt;deploymenRuntimeConfigName&gt;\n---\napiVersion: pkg.crossplane.io/v1beta1\nkind: DeploymentRuntimeConfig\nmetadata:\n  name: &lt;name&gt;\nspec:\n  serviceAccountTemplate:\n    metadata:\n      name: &lt;serviceAccountName&gt;\n---\napiVersion: kubernetes.crossplane.io/v1alpha1\nkind: ProviderConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  credentials:\n    source: InjectedIdentity\n</code></pre> <p>This is everything that is needed for the <code>storage-minio</code> configuration package to function properly.</p>"},{"location":"how-to-guides/storage-minio/#how-to-create-buckets-with-storage-minio","title":"How to create <code>Buckets</code> with <code>storage-minio</code>","text":"<p>In order to create buckets you need to specify the <code>owner</code> and the <code>bucketName</code>. Additionally, you can set the flag <code>discoverable</code> to true which adds an annotation <code>xstorages.epca.eo/discoverable</code> to the bucket resource.</p> <pre><code>apiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nspec:\n  owner: &lt;owner&gt;\n  buckets:\n    - bucketName: &lt;bucketName&gt;\n    - bucketName: &lt;bucketName&gt;\n      discoverable: true\n</code></pre>"},{"location":"how-to-guides/storage-minio/#how-to-request-access-to-buckets-from-other-owners","title":"How to request access to <code>Buckets</code> from other <code>owners</code>","text":"<p>If an <code>owner</code> wants to request access to a bucket from another <code>owner</code> it can just be added to a claim by specifying the <code>bucketAccessRequests</code>. The permission can either be <code>ReadWrite</code> or <code>ReadOnly</code>.</p> <pre><code>apiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nspec:\n  ...\n  owner: &lt;owner&gt;\n  bucketAccessRequests:\n    - bucketName: &lt;bucketName&gt;\n      permissions: &lt;permission&gt;\n  ...\n</code></pre> <p>This creates a Kubernetes object with <code>provider-kubernetes</code> that observes if the <code>&lt;owner&gt;.&lt;permission&gt;.&lt;bucketName&gt;</code> exists. If the other <code>owner</code> has not granted access to the requested bucket yet (this means that the policy does not exist yet), the <code>XStorage</code> object will switch to <code>READY: False</code> and trigger the <code>crossplane</code> reconciliation loop which continuously checks if the policy exists.</p> <p>If access is granted to the bucket, the policy is created and attached to the <code>User</code> object of the <code>owner</code>. This switches the status of the <code>XStorage</code> object back to <code>READY: True</code>.</p>"},{"location":"how-to-guides/storage-minio/#how-to-grant-access-to-buckets-to-other-owners","title":"How to grant access to <code>Buckets</code> to other <code>owners</code>","text":"<p>It is possible to grant <code>owners</code> access to a bucket without them first requesting access. However, it is only attached to the user role if the user has requested access to it as well. Similarly to the requests, the claim can include <code>bucketAccessGrants</code> that grant permissions (<code>ReadWrite</code> or <code>ReadOnly</code>) to a bucket to a list of <code>grantees</code>.</p> <pre><code>apiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: &lt;name&gt;\n  namespace: &lt;namespace&gt;\nspec:\n  ...\n  owner: &lt;owner&gt;\n  bucketAccessGrants:\n    - bucketName: &lt;bucketName&gt;\n      permissions: &lt;permission&gt;\n      grantees:\n        - &lt;grantee&gt;\n  ...\n</code></pre> <p>This creates the <code>&lt;grantee&gt;.&lt;permission&gt;.&lt;bucketName&gt;</code> policy so if the <code>grantee</code> request access to this bucket, they are automatically granted access.</p>"},{"location":"reference-guides/api/","title":"API Reference","text":"<p>Packages:</p> <ul> <li>epca.eo/v1beta1</li> </ul>"},{"location":"reference-guides/api/#epcaeov1beta1","title":"epca.eo/v1beta1","text":"<p>Resource Types:</p> <ul> <li>XStorage</li> </ul>"},{"location":"reference-guides/api/#xstorage","title":"XStorage","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required apiVersion string epca.eo/v1beta1 true kind string XStorage true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object true"},{"location":"reference-guides/api/#xstoragespec","title":"XStorage.spec","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required buckets []object            List of buckets to create and which are owned by the `owner`. true owner string            Owner of the buckets to create. true bucketAccessGrants []object            List of buckets where the `owner` grants either ReadWrite or ReadOnly permissions to other `owners` (defined in separate `Storage` claims). false bucketAccessRequests []object            List of buckets where the `owner` requests either ReadWrite or ReadOnly permissions from other `owners` (defined in separate `Storage` claims). false"},{"location":"reference-guides/api/#xstoragespecbucketsindex","title":"XStorage.spec.buckets[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket to create. true discoverable boolean            Whether this bucket should be discoverable through the catalog by other `owners` (defined in separate `Storage` claims). Default: false false"},{"location":"reference-guides/api/#xstoragespecbucketaccessgrantsindex","title":"XStorage.spec.bucketAccessGrants[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket to grant permissions to. true grantees []string            List of `owners` (defined in separate `Storage` claims) that the permission is granted to. true permission enum            Permission that is granted. Enum: ReadWrite, ReadOnly true"},{"location":"reference-guides/api/#xstoragespecbucketaccessrequestsindex","title":"XStorage.spec.bucketAccessRequests[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required bucketName string            Name of the bucket to request permissions to. true permission enum            Permission that is requested. Enum: ReadWrite, ReadOnly true"},{"location":"tutorials/storage-minio/","title":"Tutorials: storage-minio","text":"<p>These tutorials offer a series of steps to install, run and deploy your first <code>Claim</code> for the <code>storage-minio</code> configuration package. We are going to create buckets for Alice and Bob, two imaginary users. Then, Alice is going to request access to a bucket which is owned by Bob and in the last step Bob is going to grant access to Alice for this bucket.</p>"},{"location":"tutorials/storage-minio/#prerequisites","title":"Prerequisites","text":"<p>This tutorial assumes that you have go, kubectl and helm installed on your machine. Furthermore, we are using a local kind cluster for this tutorial. You can find installation instructions here.</p>"},{"location":"tutorials/storage-minio/#kind-cluster-and-crossplane-installation","title":"<code>kind</code> cluster and <code>crossplane</code> installation","text":"<p>After you have installed the necessary tools, we can create a new cluster with</p> <pre><code>kind create cluster --name storage-minio\n</code></pre> <p>and check if everything is working with</p> <pre><code>kubectl get pods -A\n</code></pre> <p>If the cluster is up and running, we need to install Crossplane. You can find more information about the installation process here.</p> <pre><code>helm repo add crossplane-stable https://charts.crossplane.io/stable\nhelm repo update\nhelm install crossplane \\\n--namespace crossplane-system \\\n--create-namespace crossplane-stable/crossplane\n</code></pre>"},{"location":"tutorials/storage-minio/#minio-installation","title":"MinIO installation","text":"<p>In order to test the functionality of <code>storage-minio</code> we need a MinIO installation. For this tutorial we install MinIO into our cluster as well.</p> <p>First, we need to install the <code>minio-operator</code>.</p> <pre><code>helm repo add minio-operator https://operator.min.io\nhelm install \\\n  --namespace minio-operator \\\n  --create-namespace \\\n  operator minio-operator/operator\n</code></pre> <p>Next, we need to install a <code>minio-tenant</code>. This is where our <code>Buckets</code>, <code>Policies</code> and <code>Users</code> actually live. Since this is only for testing, we will make the footprint of the tenant as small as possible by configuring the installation with a <code>values.yaml</code> file.</p> <pre><code># values.yaml\n\ntenant:\n  pools:\n    - servers: 1\n      name: pool-0\n      volumesPerServer: 1\n      size: 1Gi\n  certificate:\n    requestAutoCert: false\n</code></pre> <p>Now we can install the <code>minio-tenant</code> with</p> <pre><code>helm install \\\n  --values values.yaml \\\n  --namespace minio-tenant \\\n  --create-namespace \\\n  minio-tenant minio-operator/tenant\n</code></pre> <p>This concludes the prerequisites and we can finally isntall the <code>storage-minio</code> configuration package.</p>"},{"location":"tutorials/storage-minio/#storage-minio-configuration-package-installation","title":"<code>storage-minio</code> configuration package installation","text":"<p>In order to install the <code>storage-minio</code> configuration package, we first need to create a <code>Configuration</code>.</p> <pre><code># configuration.yaml\n\napiVersion: pkg.crossplane.io/v1\nkind: Configuration\nmetadata:\n  name: storage-minio\nspec:\n  package: ghcr.io/versioneer-tech/provider-storage:v0.1-minio\n</code></pre> <p>Then, we need to apply it to the cluster with</p> <pre><code>kubectl apply -f configuration.yaml\n</code></pre> <p>This automatically installs the necessary dependencies specified in the configuration package:</p> <ul> <li>provider-minio &gt;= v0.4.4</li> <li>provider-kubernetes &gt;= v0.18.0</li> <li>function-auto-ready &gt;= 0.5.0</li> <li>function-go-templating &gt;= v0.10.0</li> </ul> <p>You can check this by running</p> <pre><code>kubectl get pods -A\n</code></pre> <p>and confirm that you see pods name <code>crossplane-contrib-function-auto-ready-...</code>, <code>crossplane-contrib-provider-kubernetes-...</code>, etc. Furthermore, you should now see one <code>CompositeResourceDefinition</code> or <code>XRD</code> and one <code>Composition</code> with</p> <pre><code>kubectl get xrds\nkubectl get compositions\n</code></pre> <p>The <code>storage-minio</code> configuration package is now installed. However, it is not functional yet since it does not install the necessary <code>ProviderConfigs</code>, <code>ServiceAccounts</code>, <code>ClusterRoles</code>, <code>ClusterRoleBindings</code> and <code>Secrets</code> that are needed by the <code>provider-minio</code> and <code>provider-kubernetes</code>.</p>"},{"location":"tutorials/storage-minio/#provider-minio-configuration","title":"<code>provider-minio</code> configuration","text":"<p>For <code>storage-minio</code> to work, we need to configure the providers with a <code>ProviderConfig</code>.</p> <p>Let's start with <code>provider-minio</code>. In order for the provider to know where to actually create the resources specified in the Crossplane composition, we need to provide it with connection details through a <code>ProviderConfig</code>.</p> <p>Since we are using the MinIO instance installed in the cluster, we can forward the port for the web interface and create an API key.</p> <pre><code>kubectl port-forward pod/myminio-pool-0-0 -n minio-tenant 9090 9090\n</code></pre> <p>Navigate to <code>http://localhost:9090</code> and login with the username <code>minio</code> and <code>minio123</code>. Click on <code>Access Keys</code> and create a new access key.</p> <p>Then we need to create a <code>Secret</code> with the new access keys for <code>provider-minio</code> to connect.</p> <pre><code># secret.yaml\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: storage-minio\n  namespace: minio-tenant\nstringData:\n  AWS_ACCESS_KEY_ID: &lt;Access Key&gt;\n  AWS_SECRET_ACCESS_KEY: &lt;Secret Key&gt;\n</code></pre> <pre><code>kubectl apply -f secret.yaml\n</code></pre> <p>Finally, we can finish the setup for <code>provider-minio</code> by applying a <code>ProviderConfig</code> that references this secret.</p> <pre><code># minio-provider-config.yaml\n\napiVersion: minio.crossplane.io/v1\nkind: ProviderConfig\nmetadata:\n  name: storage-minio\n  namespace: crossplane-system\nspec:\n  credentials:\n    apiSecretRef:\n      name: storage-minio\n      namespace: minio-tenant\n    source: InjectedIdentity\n  minioURL: \"http://myminio-hl.minio-tenant.svc.cluster.local:9000/\"\n</code></pre> <pre><code>kubectl apply -f minio-provider-config.yaml\n</code></pre> <p>That's it for <code>provider-minio</code>.</p>"},{"location":"tutorials/storage-minio/#provider-kubernetes-configuration","title":"<code>provider-kubernetes</code> configuration","text":"<p>The second provider needed for <code>storage-minio</code> is <code>provider-kubernetes</code>. Since we want to observe <code>Policies</code> created by <code>provider-minio</code>, we need to create a <code>ServiceAccount</code> for <code>provider-kubernetes</code> that actually has permissions to observe these resources.</p> <p>The following file creates a <code>ServiceAccount</code>, <code>ClusterRole</code> and <code>ClusterRoleBinding</code> for those permissions.</p> <pre><code># rbac.yaml\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: storage-kubernetes\nrules:\n- apiGroups:\n  - kubernetes.crossplane.io\n  resources:\n  - objects\n  - objects/status\n  - observedobjectcollections\n  - observedobjectcollections/status\n  - providerconfigs\n  - providerconfigs/status\n  - providerconfigusages\n  - providerconfigusages/status\n  verbs:\n  - get\n  - list\n  - watch\n  - update\n  - patch\n  - create\n- apiGroups:\n  - kubernetes.crossplane.io\n  resources:\n  - '*/finalizers'\n  verbs:\n  - update\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - secrets\n  - configmaps\n  - events\n  - leases\n  verbs:\n  - '*'\n- apiGroups:\n  - minio.crossplane.io\n  resources:\n  - policies\n  verbs:\n  - watch\n  - get\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: storage-kubernetes\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: storage-kubernetes\nsubjects:\n- kind: ServiceAccount\n  name: storage-kubernetes\n  namespace: crossplane-system\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: storage-kubernetes\n  namespace: crossplane-system\n</code></pre> <pre><code>kubectl apply -f rbac.yaml\n</code></pre> <p>Now we can update <code>provider-kubernetes</code> with a <code>DeploymentRuntimeConfig</code> to use this new <code>ServiceAccount</code>. Additionally, we provide the basic <code>ProviderConfig</code> needed by <code>provider-kubernetes</code>.</p> <pre><code># kubernetes-provider-config.yaml\n\n---\napiVersion: pkg.crossplane.io/v1\nkind: Provider\nmetadata:\n  name: crossplane-contrib-provider-kubernetes\nspec:\n  package: xpkg.upbound.io/crossplane-contrib/provider-kubernetes:v0.18.0\n  runtimeConfigRef:\n    apiVersion: pkg.crossplane.io/v1beta1\n    kind: DeploymentRuntimeConfig\n    name: storage-kubernetes\n---\napiVersion: pkg.crossplane.io/v1beta1\nkind: DeploymentRuntimeConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  serviceAccountTemplate:\n    metadata:\n      name: storage-kubernetes\n---\napiVersion: kubernetes.crossplane.io/v1alpha1\nkind: ProviderConfig\nmetadata:\n  name: storage-kubernetes\nspec:\n  credentials:\n    source: InjectedIdentity\n</code></pre> <pre><code>kubectl apply -f kubernetes-provider-config.yaml\n</code></pre> <p>That's it for <code>provider-kubernetes</code> and the complete installation of <code>storage-minio</code>! Now we can finally create our first claim and see the configuration package in action!</p>"},{"location":"tutorials/storage-minio/#creating-buckets-for-alice-and-bob","title":"Creating <code>Buckets</code> for Alice and Bob","text":"<p>Everything is up and running and we can create our first claim - or rather, our first claims! Let's assume that, by default, we need two buckets for every user of the platform. Therefore, we create two two buckets named <code>alice</code> and <code>alice-shared</code> for the user \"Alice\" and <code>bob</code> and <code>bob-shared</code> for the user \"Bob\".</p> <pre><code># claims.yaml\n\n---\napiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n---\napiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre>"},{"location":"tutorials/storage-minio/#requesting-access-to-buckets-from-bob","title":"Requesting access to <code>Buckets</code> from Bob","text":"<p>Now that everyone has their buckets, Alice wants to have access to <code>bob-shared</code> since both are working on a project together and she needs access to his results. Since Alice also needs to upload her results to that bucket she needs <code>ReadWrite</code> access.</p> <pre><code># claims.yaml\n\n---\napiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre> <p>Note that the status of the <code>XStorage</code> object <code>alice-...</code> has changed to <code>READY: False</code> since the <code>alice.readwrite.bob-shared</code> policy does not exist yet and, therefore, cannot be attached to the user role.</p> <pre><code>kubectl get xstorages\n\n# Output\nNAME          SYNCED   READY   COMPOSITION        AGE\nalice-d7kbk   True     False   provider-storage   13m\nbob-2s79f     True     True    provider-storage   13m\n</code></pre> <pre><code>kubectl describe users.minio.crossplane.io alice\n\n# Output\nName:         alice\n...\nStatus:\n  At Provider:\n    Policies:   alice.owner.alice,alice.owner.alice-shared\n    Status:     enabled\n    User Name:  alice\n...\n</code></pre>"},{"location":"tutorials/storage-minio/#granting-access-to-buckets-to-alice","title":"Granting access to <code>Buckets</code> to Alice","text":"<p>Bob is the <code>owner</code> of <code>bob-shared</code> so he needs to grant Alice the <code>ReadWrite</code> permission to the bucket.</p> <pre><code># claims.yaml\n\n---\napiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: alice\nspec:\n  owner: alice\n  buckets:\n    - bucketName: alice\n    - bucketName: alice-shared\n  bucketAccessRequests:\n    - bucketName: bob-shared\n      permission: ReadWrite\n---\napiVersion: epca.eo/v1beta1\nkind: Storage\nmetadata:\n  name: bob\nspec:\n  owner: bob\n  buckets:\n    - bucketName: bob\n    - bucketName: bob-shared\n  bucketAccessGrants:\n    - bucketName: bob-shared\n      permission: ReadWrite\n      grantees:\n        - alice\n</code></pre> <pre><code>kubectl apply -f claims.yaml\n</code></pre> <p>Note that it can take up to two minutes until the new policy is observed and synced. The status of the <code>XStorage</code> object has changed back to <code>READY: True</code> since the <code>alice.readwrite.bob-shared</code> policy has been created (Bob granted access to Alice) and is now attached to the user role.</p> <pre><code>kubectl get xstorages\n\n# Output\nNAME          SYNCED   READY   COMPOSITION        AGE\nalice-d7kbk   True     True    storage-minio      15m\nbob-2s79f     True     True    storage-minio      15m\n</code></pre> <pre><code>kubectl describe users.minio.crossplane.io alice\n\n# Output\nName:         alice\n...\nStatus:\n  At Provider:\n    Policies:   alice.owner.alice,alice.owner.alice-shared,alice.readwrite.bob-shared\n    Status:     enabled\n    User Name:  alice\n...\n</code></pre>"},{"location":"tutorials/storage-minio/#conclusion","title":"Conclusion","text":"<p>Congratulations! You have worked through the whole tutorial and have installed <code>storage-minio</code> and deployed your first claims. You should no be able to follow most of the How-to guides in the sidebar and look through the API definitions in the Reference guides and see what other options you can enable/disable in the claims.</p> <p>We are always happy about feedback and suggestions on how to improve the documentation or <code>provider-storage</code> as a whole. Therefore, if you have trouble following the tutorial or find errors please open an issue on GitHub and let us know about it!</p>"}]}